<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>system&#x2F;jquery.ui.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0pr2&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0pr2&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/sapp.html">sapp</a></li>
            
                <li><a href="..&#x2F;classes/sapp.Class.html">sapp.Class</a></li>
            
                <li><a href="..&#x2F;classes/sapp.cookie.html">sapp.cookie</a></li>
            
                <li><a href="..&#x2F;classes/sapp.dom.html">sapp.dom</a></li>
            
                <li><a href="..&#x2F;classes/sapp.dom.Event.html">sapp.dom.Event</a></li>
            
                <li><a href="..&#x2F;classes/sapp.dom.Object.html">sapp.dom.Object</a></li>
            
                <li><a href="..&#x2F;classes/sapp.Http.html">sapp.Http</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.Component.html">sapp.ui.Component</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.ContextMenu.html">sapp.ui.ContextMenu</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.Dialog.html">sapp.ui.Dialog</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.FlashNotification.html">sapp.ui.FlashNotification</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.HorizontalLayout.html">sapp.ui.HorizontalLayout</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.Layout.html">sapp.ui.Layout</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.Menu.html">sapp.ui.Menu</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.MenuItem.html">sapp.ui.MenuItem</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.MessageBox.html">sapp.ui.MessageBox</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.Separator.html">sapp.ui.Separator</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.TabLayout.html">sapp.ui.TabLayout</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.TableView.html">sapp.ui.TableView</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.TableViewColumn.html">sapp.ui.TableViewColumn</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.TableViewHeading.html">sapp.ui.TableViewHeading</a></li>
            
                <li><a href="..&#x2F;classes/sapp.ui.Window.html">sapp.ui.Window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/dom.html">dom</a></li>
            
                <li><a href="..&#x2F;modules/sapp.html">sapp</a></li>
            
                <li><a href="..&#x2F;modules/ui.html">ui</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: system&#x2F;jquery.ui.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*! jQuery UI - v1.9.2 - 2012-11-27
* http:&#x2F;&#x2F;jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.position.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js
* Copyright (c) 2012 jQuery Foundation and other contributors Licensed MIT *&#x2F;

(function( $, undefined ) {

var uuid = 0,
	runiqueId = &#x2F;^ui-id-\d+$&#x2F;;

&#x2F;&#x2F; prevent duplicate loading
&#x2F;&#x2F; this is only a problem because we proxy existing functions
&#x2F;&#x2F; and we don&#x27;t want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
	return;
}

$.extend( $.ui, {
	version: &quot;1.9.2&quot;,

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

&#x2F;&#x2F; plugins
$.fn.extend({
	_focus: $.fn.focus,
	focus: function( delay, fn ) {
		return typeof delay === &quot;number&quot; ?
			this.each(function() {
				var elem = this;
				setTimeout(function() {
					$( elem ).focus();
					if ( fn ) {
						fn.call( elem );
					}
				}, delay );
			}) :
			this._focus.apply( this, arguments );
	},

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie &amp;&amp; (&#x2F;(static|relative)&#x2F;).test(this.css(&#x27;position&#x27;))) || (&#x2F;absolute&#x2F;).test(this.css(&#x27;position&#x27;))) {
			scrollParent = this.parents().filter(function() {
				return (&#x2F;(relative|absolute|fixed)&#x2F;).test($.css(this,&#x27;position&#x27;)) &amp;&amp; (&#x2F;(auto|scroll)&#x2F;).test($.css(this,&#x27;overflow&#x27;)+$.css(this,&#x27;overflow-y&#x27;)+$.css(this,&#x27;overflow-x&#x27;));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (&#x2F;(auto|scroll)&#x2F;).test($.css(this,&#x27;overflow&#x27;)+$.css(this,&#x27;overflow-y&#x27;)+$.css(this,&#x27;overflow-x&#x27;));
			}).eq(0);
		}

		return (&#x2F;fixed&#x2F;).test(this.css(&#x27;position&#x27;)) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( &quot;zIndex&quot;, zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length &amp;&amp; elem[ 0 ] !== document ) {
				&#x2F;&#x2F; Ignore z-index if position is set to a value where z-index is ignored by the browser
				&#x2F;&#x2F; This makes behavior of this function consistent across browsers
				&#x2F;&#x2F; WebKit always returns auto if the element is positioned
				position = elem.css( &quot;position&quot; );
				if ( position === &quot;absolute&quot; || position === &quot;relative&quot; || position === &quot;fixed&quot; ) {
					&#x2F;&#x2F; IE returns 0 when zIndex is not specified
					&#x2F;&#x2F; other browsers return a string
					&#x2F;&#x2F; we ignore the case of nested elements with an explicit value of 0
					&#x2F;&#x2F; &lt;div style=&quot;z-index: -10;&quot;&gt;&lt;div style=&quot;z-index: 0;&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;
					value = parseInt( elem.css( &quot;zIndex&quot; ), 10 );
					if ( !isNaN( value ) &amp;&amp; value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = &quot;ui-id-&quot; + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( &quot;id&quot; );
			}
		});
	}
});

&#x2F;&#x2F; selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( &quot;area&quot; === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== &quot;map&quot; ) {
			return false;
		}
		img = $( &quot;img[usemap=#&quot; + mapName + &quot;]&quot; )[0];
		return !!img &amp;&amp; visible( img );
	}
	return ( &#x2F;input|select|textarea|button|object&#x2F;.test( nodeName ) ?
		!element.disabled :
		&quot;a&quot; === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &amp;&amp;
		&#x2F;&#x2F; the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &amp;&amp;
		!$( element ).parents().andSelf().filter(function() {
			return $.css( this, &quot;visibility&quot; ) === &quot;hidden&quot;;
		}).length;
}

$.extend( $.expr[ &quot;:&quot; ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		&#x2F;&#x2F; support: jQuery &lt;1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, &quot;tabindex&quot; ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, &quot;tabindex&quot; ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex &gt;= 0 ) &amp;&amp; focusable( element, !isTabIndexNaN );
	}
});

&#x2F;&#x2F; support
$(function() {
	var body = document.body,
		div = body.appendChild( div = document.createElement( &quot;div&quot; ) );

	&#x2F;&#x2F; access offsetHeight before setting the style to prevent a layout bug
	&#x2F;&#x2F; in IE 9 which causes the element to continue to take up space even
	&#x2F;&#x2F; after it is removed from the DOM (#8026)
	div.offsetHeight;

	$.extend( div.style, {
		minHeight: &quot;100px&quot;,
		height: &quot;auto&quot;,
		padding: 0,
		borderWidth: 0
	});

	$.support.minHeight = div.offsetHeight === 100;
	$.support.selectstart = &quot;onselectstart&quot; in div;

	&#x2F;&#x2F; set display to none to avoid a layout bug in IE
	&#x2F;&#x2F; http:&#x2F;&#x2F;dev.jquery.com&#x2F;ticket&#x2F;4014
	body.removeChild( div ).style.display = &quot;none&quot;;
});

&#x2F;&#x2F; support: jQuery &lt;1.8
if ( !$( &quot;&lt;a&gt;&quot; ).outerWidth( 1 ).jquery ) {
	$.each( [ &quot;Width&quot;, &quot;Height&quot; ], function( i, name ) {
		var side = name === &quot;Width&quot; ? [ &quot;Left&quot;, &quot;Right&quot; ] : [ &quot;Top&quot;, &quot;Bottom&quot; ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, &quot;padding&quot; + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, &quot;border&quot; + this + &quot;Width&quot; ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, &quot;margin&quot; + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ &quot;inner&quot; + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ &quot;inner&quot; + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + &quot;px&quot; );
			});
		};

		$.fn[ &quot;outer&quot; + name] = function( size, margin ) {
			if ( typeof size !== &quot;number&quot; ) {
				return orig[ &quot;outer&quot; + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + &quot;px&quot; );
			});
		};
	});
}

&#x2F;&#x2F; support: jQuery 1.6.1, 1.6.2 (http:&#x2F;&#x2F;bugs.jquery.com&#x2F;ticket&#x2F;9413)
if ( $( &quot;&lt;a&gt;&quot; ).data( &quot;a-b&quot;, &quot;a&quot; ).removeData( &quot;a-b&quot; ).data( &quot;a-b&quot; ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





&#x2F;&#x2F; deprecated

(function() {
	var uaMatch = &#x2F;msie ([\w.]+)&#x2F;.exec( navigator.userAgent.toLowerCase() ) || [];
	$.ui.ie = uaMatch.length ? true : false;
	$.ui.ie6 = parseFloat( uaMatch[ 1 ], 10 ) === 6;
})();

$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? &quot;selectstart&quot; : &quot;mousedown&quot; ) +
			&quot;.ui-disableSelection&quot;, function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( &quot;.ui-disableSelection&quot; );
	}
});

$.extend( $.ui, {
	&#x2F;&#x2F; $.ui.plugin is deprecated.  Use the proxy pattern instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i &lt; set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	contains: $.contains,

	&#x2F;&#x2F; only used by resizable
	hasScroll: function( el, a ) {

		&#x2F;&#x2F;If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( &quot;overflow&quot; ) === &quot;hidden&quot;) {
			return false;
		}

		var scroll = ( a &amp;&amp; a === &quot;left&quot; ) ? &quot;scrollLeft&quot; : &quot;scrollTop&quot;,
			has = false;

		if ( el[ scroll ] &gt; 0 ) {
			return true;
		}

		&#x2F;&#x2F; TODO: determine which cases actually cause this to happen
		&#x2F;&#x2F; if the element doesn&#x27;t have the scroll set, see if it&#x27;s possible to
		&#x2F;&#x2F; set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] &gt; 0 );
		el[ scroll ] = 0;
		return has;
	},

	&#x2F;&#x2F; these are odd functions, fix the API or move into individual plugins
	isOverAxis: function( x, reference, size ) {
		&#x2F;&#x2F;Determines when x coordinate is over &quot;b&quot; element axis
		return ( x &gt; reference ) &amp;&amp; ( x &lt; ( reference + size ) );
	},
	isOver: function( y, x, top, left, height, width ) {
		&#x2F;&#x2F;Determines when x, y coordinates is over &quot;b&quot; element
		return $.ui.isOverAxis( y, top, height ) &amp;&amp; $.ui.isOverAxis( x, left, width );
	}
});

})( jQuery );
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( &quot;remove&quot; );
		&#x2F;&#x2F; http:&#x2F;&#x2F;bugs.jquery.com&#x2F;ticket&#x2F;8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		namespace = name.split( &quot;.&quot; )[ 0 ];

	name = name.split( &quot;.&quot; )[ 1 ];
	fullName = namespace + &quot;-&quot; + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	&#x2F;&#x2F; create selector for plugin
	$.expr[ &quot;:&quot; ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		&#x2F;&#x2F; allow instantiation without &quot;new&quot; keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		&#x2F;&#x2F; allow instantiation without initializing for simple inheritance
		&#x2F;&#x2F; must use &quot;new&quot; keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	&#x2F;&#x2F; extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		&#x2F;&#x2F; copy the object used to create the prototype in case we need to
		&#x2F;&#x2F; redefine the widget later
		_proto: $.extend( {}, prototype ),
		&#x2F;&#x2F; track widgets that inherit from this widget in case this widget is
		&#x2F;&#x2F; redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	&#x2F;&#x2F; we need to make the options hash a property directly on the new instance
	&#x2F;&#x2F; otherwise we&#x27;ll modify the options hash on the prototype that we&#x27;re
	&#x2F;&#x2F; inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( $.isFunction( value ) ) {
			prototype[ prop ] = (function() {
				var _super = function() {
						return base.prototype[ prop ].apply( this, arguments );
					},
					_superApply = function( args ) {
						return base.prototype[ prop ].apply( this, args );
					};
				return function() {
					var __super = this._super,
						__superApply = this._superApply,
						returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply( this, arguments );

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			})();
		}
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		&#x2F;&#x2F; TODO: remove support for widgetEventPrefix
		&#x2F;&#x2F; always use the name + a colon as the prefix, e.g., draggable:start
		&#x2F;&#x2F; don&#x27;t prefix for widgets that aren&#x27;t DOM-based
		widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name
	}, prototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		&#x2F;&#x2F; TODO remove widgetBaseClass, see #8155
		widgetBaseClass: fullName,
		widgetFullName: fullName
	});

	&#x2F;&#x2F; If this widget is being redefined then we need to find all widgets that
	&#x2F;&#x2F; are inheriting from it and redefine all of them so that they inherit from
	&#x2F;&#x2F; the new version of this widget. We&#x27;re essentially trying to replace one
	&#x2F;&#x2F; level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			&#x2F;&#x2F; redefine the child widget using the same prototype that was
			&#x2F;&#x2F; originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + &quot;.&quot; + childPrototype.widgetName, constructor, child._proto );
		});
		&#x2F;&#x2F; remove the list of existing child constructors from the old constructor
		&#x2F;&#x2F; so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex &lt; inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) &amp;&amp; value !== undefined ) {
				&#x2F;&#x2F; Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						&#x2F;&#x2F; Don&#x27;t extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				&#x2F;&#x2F; Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === &quot;string&quot;,
			args = slice.call( arguments, 1 ),
			returnValue = this;

		&#x2F;&#x2F; allow multiple hashes to be passed on init
		options = !isMethodCall &amp;&amp; args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( &quot;cannot call methods on &quot; + name + &quot; prior to initialization; &quot; +
						&quot;attempted to call method &#x27;&quot; + options + &quot;&#x27;&quot; );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === &quot;_&quot; ) {
					return $.error( &quot;no such method &#x27;&quot; + options + &quot;&#x27; for &quot; + name + &quot; widget instance&quot; );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance &amp;&amp; methodValue !== undefined ) {
					returnValue = methodValue &amp;&amp; methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( &#x2F;* options, element *&#x2F; ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: &quot;widget&quot;,
	widgetEventPrefix: &quot;&quot;,
	defaultElement: &quot;&lt;div&gt;&quot;,
	options: {
		disabled: false,

		&#x2F;&#x2F; callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = &quot;.&quot; + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			&#x2F;&#x2F; 1.9 BC for #7810
			&#x2F;&#x2F; TODO remove dual storage
			$.data( element, this.widgetName, this );
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				&#x2F;&#x2F; element within the document
				element.ownerDocument :
				&#x2F;&#x2F; element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( &quot;create&quot;, null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		&#x2F;&#x2F; we can probably remove the unbind calls in 2.0
		&#x2F;&#x2F; all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			&#x2F;&#x2F; 1.9 BC for #7810
			&#x2F;&#x2F; TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			&#x2F;&#x2F; support: jquery &lt;1.6.3
			&#x2F;&#x2F; http:&#x2F;&#x2F;bugs.jquery.com&#x2F;ticket&#x2F;9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( &quot;aria-disabled&quot; )
			.removeClass(
				this.widgetFullName + &quot;-disabled &quot; +
				&quot;ui-state-disabled&quot; );

		&#x2F;&#x2F; clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( &quot;ui-state-hover&quot; );
		this.focusable.removeClass( &quot;ui-state-focus&quot; );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			&#x2F;&#x2F; don&#x27;t return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === &quot;string&quot; ) {
			&#x2F;&#x2F; handle nested keys, e.g., &quot;foo.bar&quot; =&gt; { foo: { bar: ___ } }
			options = {};
			parts = key.split( &quot;.&quot; );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i &lt; parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === &quot;disabled&quot; ) {
			this.widget()
				.toggleClass( this.widgetFullName + &quot;-disabled ui-state-disabled&quot;, !!value )
				.attr( &quot;aria-disabled&quot;, value );
			this.hoverable.removeClass( &quot;ui-state-hover&quot; );
			this.focusable.removeClass( &quot;ui-state-focus&quot; );
		}

		return this;
	},

	enable: function() {
		return this._setOption( &quot;disabled&quot;, false );
	},
	disable: function() {
		return this._setOption( &quot;disabled&quot;, true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		&#x2F;&#x2F; no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== &quot;boolean&quot; ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		&#x2F;&#x2F; no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			&#x2F;&#x2F; accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				&#x2F;&#x2F; allow widgets to customize the disabled handling
				&#x2F;&#x2F; - disabled as an array instead of boolean
				&#x2F;&#x2F; - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &amp;&amp;
						( instance.options.disabled === true ||
							$( this ).hasClass( &quot;ui-state-disabled&quot; ) ) ) {
					return;
				}
				return ( typeof handler === &quot;string&quot; ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			&#x2F;&#x2F; copy the guid so direct unbinding works
			if ( typeof handler !== &quot;string&quot; ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( &#x2F;^(\w+)\s*(.*)$&#x2F; ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || &quot;&quot;).split( &quot; &quot; ).join( this.eventNamespace + &quot; &quot; ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === &quot;string&quot; ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( &quot;ui-state-hover&quot; );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( &quot;ui-state-hover&quot; );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( &quot;ui-state-focus&quot; );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( &quot;ui-state-focus&quot; );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		&#x2F;&#x2F; the original event may come from any element
		&#x2F;&#x2F; so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		&#x2F;&#x2F; copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &amp;&amp;
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: &quot;fadeIn&quot;, hide: &quot;fadeOut&quot; }, function( method, defaultEffect ) {
	$.Widget.prototype[ &quot;_&quot; + method ] = function( element, options, callback ) {
		if ( typeof options === &quot;string&quot; ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === &quot;number&quot; ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === &quot;number&quot; ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions &amp;&amp; $.effects &amp;&amp; ( $.effects.effect[ effectName ] || $.uiBackCompat !== false &amp;&amp; $.effects[ effectName ] ) ) {
			element[ method ]( options );
		} else if ( effectName !== method &amp;&amp; element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

&#x2F;&#x2F; DEPRECATED
if ( $.uiBackCompat !== false ) {
	$.Widget.prototype._getCreateOptions = function() {
		return $.metadata &amp;&amp; $.metadata.get( this.element[0] )[ this.widgetName ];
	};
}

})( jQuery );
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function( e ) {
	mouseHandled = false;
});

$.widget(&quot;ui.mouse&quot;, {
	version: &quot;1.9.2&quot;,
	options: {
		cancel: &#x27;input,textarea,button,select,option&#x27;,
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind(&#x27;mousedown.&#x27;+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind(&#x27;click.&#x27;+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + &#x27;.preventClickEvent&#x27;)) {
					$.removeData(event.target, that.widgetName + &#x27;.preventClickEvent&#x27;);
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	&#x2F;&#x2F; TODO: make sure destroying one instance of mouse doesn&#x27;t mess with
	&#x2F;&#x2F; other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind(&#x27;.&#x27;+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind(&#x27;mousemove.&#x27;+this.widgetName, this._mouseMoveDelegate)
				.unbind(&#x27;mouseup.&#x27;+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		&#x2F;&#x2F; don&#x27;t let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		&#x2F;&#x2F; we may have missed mouseup (out of window)
		(this._mouseStarted &amp;&amp; this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			&#x2F;&#x2F; event.target.nodeName works around a bug in IE 8 with
			&#x2F;&#x2F; disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === &quot;string&quot; &amp;&amp; event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) &amp;&amp; this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		&#x2F;&#x2F; Click event may never have fired (Gecko &amp; Opera)
		if (true === $.data(event.target, this.widgetName + &#x27;.preventClickEvent&#x27;)) {
			$.removeData(event.target, this.widgetName + &#x27;.preventClickEvent&#x27;);
		}

		&#x2F;&#x2F; these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind(&#x27;mousemove.&#x27;+this.widgetName, this._mouseMoveDelegate)
			.bind(&#x27;mouseup.&#x27;+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		&#x2F;&#x2F; IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie &amp;&amp; !(document.documentMode &gt;= 9) &amp;&amp; !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) &amp;&amp; this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind(&#x27;mousemove.&#x27;+this.widgetName, this._mouseMoveDelegate)
			.unbind(&#x27;mouseup.&#x27;+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + &#x27;.preventClickEvent&#x27;, true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) &gt;= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	&#x2F;&#x2F; These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);
(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = &#x2F;left|center|right&#x2F;,
	rvertical = &#x2F;top|center|bottom&#x2F;,
	roffset = &#x2F;[\+\-]\d+%?&#x2F;,
	rposition = &#x2F;^\w+&#x2F;,
	rpercent = &#x2F;%$&#x2F;,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseInt( offsets[ 0 ], 10 ) * ( rpercent.test( offsets[ 0 ] ) ? width &#x2F; 100 : 1 ),
		parseInt( offsets[ 1 ], 10 ) * ( rpercent.test( offsets[ 1 ] ) ? height &#x2F; 100 : 1 )
	];
}
function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( &quot;&lt;div style=&#x27;display:block;width:50px;height:50px;overflow:hidden;&#x27;&gt;&lt;div style=&#x27;height:100px;width:auto;&#x27;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&quot; ),
			innerDiv = div.children()[0];

		$( &quot;body&quot; ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( &quot;overflow&quot;, &quot;scroll&quot; );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow ? &quot;&quot; : within.element.css( &quot;overflow-x&quot; ),
			overflowY = within.isWindow ? &quot;&quot; : within.element.css( &quot;overflow-y&quot; ),
			hasOverflowX = overflowX === &quot;scroll&quot; ||
				( overflowX === &quot;auto&quot; &amp;&amp; within.width &lt; within.element[0].scrollWidth ),
			hasOverflowY = overflowY === &quot;scroll&quot; ||
				( overflowY === &quot;auto&quot; &amp;&amp; within.height &lt; within.element[0].scrollHeight );
		return {
			width: hasOverflowX ? $.position.scrollbarWidth() : 0,
			height: hasOverflowY ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] );
		return {
			element: withinElement,
			isWindow: isWindow,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	&#x2F;&#x2F; make a copy, we don&#x27;t want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		targetElem = target[0],
		collision = ( options.collision || &quot;flip&quot; ).split( &quot; &quot; ),
		offsets = {};

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		targetOffset = { top: 0, left: 0 };
	} else if ( $.isWindow( targetElem ) ) {
		targetWidth = target.width();
		targetHeight = target.height();
		targetOffset = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		&#x2F;&#x2F; force left top to allow flipping
		options.at = &quot;left top&quot;;
		targetWidth = targetHeight = 0;
		targetOffset = { top: targetElem.pageY, left: targetElem.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		targetOffset = target.offset();
	}
	&#x2F;&#x2F; clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	&#x2F;&#x2F; force my and at to have valid horizontal and vertical positions
	&#x2F;&#x2F; if a value is missing or invalid, it will be converted to center
	$.each( [ &quot;my&quot;, &quot;at&quot; ], function() {
		var pos = ( options[ this ] || &quot;&quot; ).split( &quot; &quot; ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ &quot;center&quot; ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ &quot;center&quot; ].concat( pos ) :
					[ &quot;center&quot;, &quot;center&quot; ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : &quot;center&quot;;
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : &quot;center&quot;;

		&#x2F;&#x2F; calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		&#x2F;&#x2F; reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	&#x2F;&#x2F; normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === &quot;right&quot; ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === &quot;center&quot; ) {
		basePosition.left += targetWidth &#x2F; 2;
	}

	if ( options.at[ 1 ] === &quot;bottom&quot; ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === &quot;center&quot; ) {
		basePosition.top += targetHeight &#x2F; 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, &quot;marginLeft&quot; ),
			marginTop = parseCss( this, &quot;marginTop&quot; ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, &quot;marginRight&quot; ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, &quot;marginBottom&quot; ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === &quot;right&quot; ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === &quot;center&quot; ) {
			position.left -= elemWidth &#x2F; 2;
		}

		if ( options.my[ 1 ] === &quot;bottom&quot; ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === &quot;center&quot; ) {
			position.top -= elemHeight &#x2F; 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		&#x2F;&#x2F; if the browser doesn&#x27;t support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ &quot;left&quot;, &quot;top&quot; ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}

		if ( options.using ) {
			&#x2F;&#x2F; adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right &lt; 0 ? &quot;left&quot; : left &gt; 0 ? &quot;right&quot; : &quot;center&quot;,
						vertical: bottom &lt; 0 ? &quot;top&quot; : top &gt; 0 ? &quot;bottom&quot; : &quot;middle&quot;
					};
				if ( targetWidth &lt; elemWidth &amp;&amp; abs( left + right ) &lt; targetWidth ) {
					feedback.horizontal = &quot;center&quot;;
				}
				if ( targetHeight &lt; elemHeight &amp;&amp; abs( top + bottom ) &lt; targetHeight ) {
					feedback.vertical = &quot;middle&quot;;
				}
				if ( max( abs( left ), abs( right ) ) &gt; max( abs( top ), abs( bottom ) ) ) {
					feedback.important = &quot;horizontal&quot;;
				} else {
					feedback.important = &quot;vertical&quot;;
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			&#x2F;&#x2F; element is wider than within
			if ( data.collisionWidth &gt; outerWidth ) {
				&#x2F;&#x2F; element is initially over the left side of within
				if ( overLeft &gt; 0 &amp;&amp; overRight &lt;= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				&#x2F;&#x2F; element is initially over right side of within
				} else if ( overRight &gt; 0 &amp;&amp; overLeft &lt;= 0 ) {
					position.left = withinOffset;
				&#x2F;&#x2F; element is initially over both left and right sides of within
				} else {
					if ( overLeft &gt; overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			&#x2F;&#x2F; too far left -&gt; align with left edge
			} else if ( overLeft &gt; 0 ) {
				position.left += overLeft;
			&#x2F;&#x2F; too far right -&gt; align with right edge
			} else if ( overRight &gt; 0 ) {
				position.left -= overRight;
			&#x2F;&#x2F; adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			&#x2F;&#x2F; element is taller than within
			if ( data.collisionHeight &gt; outerHeight ) {
				&#x2F;&#x2F; element is initially over the top of within
				if ( overTop &gt; 0 &amp;&amp; overBottom &lt;= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				&#x2F;&#x2F; element is initially over bottom of within
				} else if ( overBottom &gt; 0 &amp;&amp; overTop &lt;= 0 ) {
					position.top = withinOffset;
				&#x2F;&#x2F; element is initially over both top and bottom of within
				} else {
					if ( overTop &gt; overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			&#x2F;&#x2F; too far up -&gt; align with top
			} else if ( overTop &gt; 0 ) {
				position.top += overTop;
			&#x2F;&#x2F; too far down -&gt; align with bottom edge
			} else if ( overBottom &gt; 0 ) {
				position.top -= overBottom;
			&#x2F;&#x2F; adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === &quot;left&quot; ?
					-data.elemWidth :
					data.my[ 0 ] === &quot;right&quot; ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === &quot;left&quot; ?
					data.targetWidth :
					data.at[ 0 ] === &quot;right&quot; ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft &lt; 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight &lt; 0 || newOverRight &lt; abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight &gt; 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft &gt; 0 || abs( newOverLeft ) &lt; overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === &quot;top&quot;,
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === &quot;bottom&quot; ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === &quot;top&quot; ?
					data.targetHeight :
					data.at[ 1 ] === &quot;bottom&quot; ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop &lt; 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) &gt; overTop &amp;&amp; ( newOverBottom &lt; 0 || newOverBottom &lt; abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom &gt; 0 ) {
				newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) &gt; overBottom &amp;&amp; ( newOverTop &gt; 0 || abs( newOverTop ) &lt; overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

&#x2F;&#x2F; fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( &quot;body&quot; )[ 0 ],
		div = document.createElement( &quot;div&quot; );

	&#x2F;&#x2F;Create a &quot;fake body&quot; for testing based on method used in jQuery.support
	testElement = document.createElement( body ? &quot;div&quot; : &quot;body&quot; );
	testElementStyle = {
		visibility: &quot;hidden&quot;,
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: &quot;none&quot;
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: &quot;absolute&quot;,
			left: &quot;-1000px&quot;,
			top: &quot;-1000px&quot;
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = &quot;position: absolute; left: 10.7432222px;&quot;;

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft &gt; 10 &amp;&amp; offsetLeft &lt; 11;

	testElement.innerHTML = &quot;&quot;;
	testElementParent.removeChild( testElement );
})();

&#x2F;&#x2F; DEPRECATED
if ( $.uiBackCompat !== false ) {
	&#x2F;&#x2F; offset option
	(function( $ ) {
		var _position = $.fn.position;
		$.fn.position = function( options ) {
			if ( !options || !options.offset ) {
				return _position.call( this, options );
			}
			var offset = options.offset.split( &quot; &quot; ),
				at = options.at.split( &quot; &quot; );
			if ( offset.length === 1 ) {
				offset[ 1 ] = offset[ 0 ];
			}
			if ( &#x2F;^\d&#x2F;.test( offset[ 0 ] ) ) {
				offset[ 0 ] = &quot;+&quot; + offset[ 0 ];
			}
			if ( &#x2F;^\d&#x2F;.test( offset[ 1 ] ) ) {
				offset[ 1 ] = &quot;+&quot; + offset[ 1 ];
			}
			if ( at.length === 1 ) {
				if ( &#x2F;left|center|right&#x2F;.test( at[ 0 ] ) ) {
					at[ 1 ] = &quot;center&quot;;
				} else {
					at[ 1 ] = at[ 0 ];
					at[ 0 ] = &quot;center&quot;;
				}
			}
			return _position.call( this, $.extend( options, {
				at: at[ 0 ] + offset[ 0 ] + &quot; &quot; + at[ 1 ] + offset[ 1 ],
				offset: undefined
			} ) );
		};
	}( jQuery ) );
}

}( jQuery ) );
(function( $, undefined ) {

$.widget(&quot;ui.draggable&quot;, $.ui.mouse, {
	version: &quot;1.9.2&quot;,
	widgetEventPrefix: &quot;drag&quot;,
	options: {
		addClasses: true,
		appendTo: &quot;parent&quot;,
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: &quot;auto&quot;,
		cursorAt: false,
		grid: false,
		handle: false,
		helper: &quot;original&quot;,
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: &quot;default&quot;,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: &quot;both&quot;,
		snapTolerance: 20,
		stack: false,
		zIndex: false
	},
	_create: function() {

		if (this.options.helper == &#x27;original&#x27; &amp;&amp; !(&#x2F;^(?:r|a|f)&#x2F;).test(this.element.css(&quot;position&quot;)))
			this.element[0].style.position = &#x27;relative&#x27;;

		(this.options.addClasses &amp;&amp; this.element.addClass(&quot;ui-draggable&quot;));
		(this.options.disabled &amp;&amp; this.element.addClass(&quot;ui-draggable-disabled&quot;));

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( &quot;ui-draggable ui-draggable-dragging ui-draggable-disabled&quot; );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		&#x2F;&#x2F; among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).is(&#x27;.ui-resizable-handle&#x27;))
			return false;

		&#x2F;&#x2F;Quit if we&#x27;re not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle)
			return false;

		$(o.iframeFix === true ? &quot;iframe&quot; : o.iframeFix).each(function() {
			$(&#x27;&lt;div class=&quot;ui-draggable-iframeFix&quot; style=&quot;background: #fff;&quot;&gt;&lt;&#x2F;div&gt;&#x27;)
			.css({
				width: this.offsetWidth+&quot;px&quot;, height: this.offsetHeight+&quot;px&quot;,
				position: &quot;absolute&quot;, opacity: &quot;0.001&quot;, zIndex: 1000
			})
			.css($(this).offset())
			.appendTo(&quot;body&quot;);
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		&#x2F;&#x2F;Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass(&quot;ui-draggable-dragging&quot;);

		&#x2F;&#x2F;Cache the helper size
		this._cacheHelperProportions();

		&#x2F;&#x2F;If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		&#x2F;*
		 * - Position generation -
		 * This block generates everything position related - it&#x27;s the core of draggables.
		 *&#x2F;

		&#x2F;&#x2F;Cache the margins of the original element
		this._cacheMargins();

		&#x2F;&#x2F;Store the helper&#x27;s css position
		this.cssPosition = this.helper.css(&quot;position&quot;);
		this.scrollParent = this.helper.scrollParent();

		&#x2F;&#x2F;The element&#x27;s absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { &#x2F;&#x2F;Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() &#x2F;&#x2F;This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		&#x2F;&#x2F;Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		&#x2F;&#x2F;Adjust the mouse offset relative to the helper if &#x27;cursorAt&#x27; is supplied
		(o.cursorAt &amp;&amp; this._adjustOffsetFromHelper(o.cursorAt));

		&#x2F;&#x2F;Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		&#x2F;&#x2F;Trigger event + callbacks
		if(this._trigger(&quot;start&quot;, event) === false) {
			this._clear();
			return false;
		}

		&#x2F;&#x2F;Recache the helper size
		this._cacheHelperProportions();

		&#x2F;&#x2F;Prepare the droppable offsets
		if ($.ui.ddmanager &amp;&amp; !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);


		this._mouseDrag(event, true); &#x2F;&#x2F;Execute the drag once - this causes the helper not to be visible before getting its correct position

		&#x2F;&#x2F;If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);

		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		&#x2F;&#x2F;Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		&#x2F;&#x2F;Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger(&#x27;drag&#x27;, event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis != &quot;y&quot;) this.helper[0].style.left = this.position.left+&#x27;px&#x27;;
		if(!this.options.axis || this.options.axis != &quot;x&quot;) this.helper[0].style.top = this.position.top+&#x27;px&#x27;;
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		return false;
	},

	_mouseStop: function(event) {

		&#x2F;&#x2F;If we are using droppables, inform the manager about the drop
		var dropped = false;
		if ($.ui.ddmanager &amp;&amp; !this.options.dropBehaviour)
			dropped = $.ui.ddmanager.drop(this, event);

		&#x2F;&#x2F;if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		&#x2F;&#x2F;if the original element is no longer in the DOM don&#x27;t bother to continue (see #8269)
		var element = this.element[0], elementInDom = false;
		while ( element &amp;&amp; (element = element.parentNode) ) {
			if (element == document ) {
				elementInDom = true;
			}
		}
		if ( !elementInDom &amp;&amp; this.options.helper === &quot;original&quot; )
			return false;

		if((this.options.revert == &quot;invalid&quot; &amp;&amp; !dropped) || (this.options.revert == &quot;valid&quot; &amp;&amp; dropped) || this.options.revert === true || ($.isFunction(this.options.revert) &amp;&amp; this.options.revert.call(this.element, dropped))) {
			var that = this;
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger(&quot;stop&quot;, event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger(&quot;stop&quot;, event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		&#x2F;&#x2F;Remove frame helpers
		$(&quot;div.ui-draggable-iframeFix&quot;).each(function() {
			this.parentNode.removeChild(this);
		});

		&#x2F;&#x2F;If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if(this.helper.is(&quot;.ui-draggable-dragging&quot;)) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find(&quot;*&quot;)
			.andSelf()
			.each(function() {
				if(this == event.target) handle = true;
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == &#x27;clone&#x27; ? this.element.clone().removeAttr(&#x27;id&#x27;) : this.element);

		if(!helper.parents(&#x27;body&#x27;).length)
			helper.appendTo((o.appendTo == &#x27;parent&#x27; ? this.element[0].parentNode : o.appendTo));

		if(helper[0] != this.element[0] &amp;&amp; !(&#x2F;(fixed|absolute)&#x2F;).test(helper.css(&quot;position&quot;)))
			helper.css(&quot;position&quot;, &quot;absolute&quot;);

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == &#x27;string&#x27;) {
			obj = obj.split(&#x27; &#x27;);
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if (&#x27;left&#x27; in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if (&#x27;right&#x27; in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if (&#x27;top&#x27; in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if (&#x27;bottom&#x27; in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		&#x2F;&#x2F;Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		&#x2F;&#x2F; This is a special case where we need to modify a offset calculated on start, since the following happened:
		&#x2F;&#x2F; 1. The position of the helper is absolute, so it&#x27;s position is calculated based on the next positioned parent
		&#x2F;&#x2F; 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn&#x27;t the document, which means that
		&#x2F;&#x2F;    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == &#x27;absolute&#x27; &amp;&amp; this.scrollParent[0] != document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) &#x2F;&#x2F;This needs to be actually done for all browsers, since pageX&#x2F;pageY includes this information
		|| (this.offsetParent[0].tagName &amp;&amp; this.offsetParent[0].tagName.toLowerCase() == &#x27;html&#x27; &amp;&amp; $.ui.ie)) &#x2F;&#x2F;Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css(&quot;borderTopWidth&quot;),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css(&quot;borderLeftWidth&quot;),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == &quot;relative&quot;) {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css(&quot;top&quot;),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css(&quot;left&quot;),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css(&quot;marginLeft&quot;),10) || 0),
			top: (parseInt(this.element.css(&quot;marginTop&quot;),10) || 0),
			right: (parseInt(this.element.css(&quot;marginRight&quot;),10) || 0),
			bottom: (parseInt(this.element.css(&quot;marginBottom&quot;),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == &#x27;parent&#x27;) o.containment = this.helper[0].parentNode;
		if(o.containment == &#x27;document&#x27; || o.containment == &#x27;window&#x27;) this.containment = [
			o.containment == &#x27;document&#x27; ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
			o.containment == &#x27;document&#x27; ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
			(o.containment == &#x27;document&#x27; ? 0 : $(window).scrollLeft()) + $(o.containment == &#x27;document&#x27; ? document : window).width() - this.helperProportions.width - this.margins.left,
			(o.containment == &#x27;document&#x27; ? 0 : $(window).scrollTop()) + ($(o.containment == &#x27;document&#x27; ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(&#x2F;^(document|window|parent)$&#x2F;).test(o.containment) &amp;&amp; o.containment.constructor != Array) {
			var c = $(o.containment);
			var ce = c[0]; if(!ce) return;
			var co = c.offset();
			var over = ($(ce).css(&quot;overflow&quot;) != &#x27;hidden&#x27;);

			this.containment = [
				(parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingLeft&quot;),10) || 0),
				(parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingTop&quot;),10) || 0),
				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingRight&quot;),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingBottom&quot;),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;

		} else if(o.containment.constructor == Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == &quot;absolute&quot; ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == &#x27;absolute&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (&#x2F;(html|body)&#x2F;i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	&#x2F;&#x2F; The absolute mouse position
				+ this.offset.relative.top * mod										&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				- ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																&#x2F;&#x2F; The absolute mouse position
				+ this.offset.relative.left * mod										&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				- ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == &#x27;absolute&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (&#x2F;(html|body)&#x2F;i).test(scroll[0].tagName);
		var pageX = event.pageX;
		var pageY = event.pageY;

		&#x2F;*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 *&#x2F;

		if(this.originalPosition) { &#x2F;&#x2F;If we are not dragging yet, we won&#x27;t check for options
			var containment;
			if(this.containment) {
			if (this.relative_container){
				var co = this.relative_container.offset();
				containment = [ this.containment[0] + co.left,
					this.containment[1] + co.top,
					this.containment[2] + co.left,
					this.containment[3] + co.top ];
			}
			else {
				containment = this.containment;
			}

				if(event.pageX - this.offset.click.left &lt; containment[0]) pageX = containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &lt; containment[1]) pageY = containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left &gt; containment[2]) pageX = containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &gt; containment[3]) pageY = containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				&#x2F;&#x2F;Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) &#x2F; o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? (!(top - this.offset.click.top &lt; containment[1] || top - this.offset.click.top &gt; containment[3]) ? top : (!(top - this.offset.click.top &lt; containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) &#x2F; o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? (!(left - this.offset.click.left &lt; containment[0] || left - this.offset.click.left &gt; containment[2]) ? left : (!(left - this.offset.click.left &lt; containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																&#x2F;&#x2F; The absolute mouse position
				- this.offset.click.top													&#x2F;&#x2F; Click offset (relative to the element)
				- this.offset.relative.top												&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				+ ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																&#x2F;&#x2F; The absolute mouse position
				- this.offset.click.left												&#x2F;&#x2F; Click offset (relative to the element)
				- this.offset.relative.left												&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				+ ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass(&quot;ui-draggable-dragging&quot;);
		if(this.helper[0] != this.element[0] &amp;&amp; !this.cancelHelperRemoval) this.helper.remove();
		&#x2F;&#x2F;if($.ui.ddmanager) $.ui.ddmanager.current = null;
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	&#x2F;&#x2F; From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		if(type == &quot;drag&quot;) this.positionAbs = this._convertPositionTo(&quot;absolute&quot;); &#x2F;&#x2F;The absolute position has to be recalculated after plugins
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function(event) {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add(&quot;draggable&quot;, &quot;connectToSortable&quot;, {
	start: function(event, ui) {

		var inst = $(this).data(&quot;draggable&quot;), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, &#x27;sortable&#x27;);
			if (sortable &amp;&amp; !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	&#x2F;&#x2F; Call the sortable&#x27;s refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it&#x27;s initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger(&quot;activate&quot;, event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		&#x2F;&#x2F;If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data(&quot;draggable&quot;),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; &#x2F;&#x2F;Don&#x27;t remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; &#x2F;&#x2F;Remove it in the sortable instance (so sortable plugins like revert still work)

				&#x2F;&#x2F;The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: &#x27;valid&#x2F;invalid&#x27;
				if(this.shouldRevert) this.instance.options.revert = true;

				&#x2F;&#x2F;Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				&#x2F;&#x2F;If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper == &#x27;original&#x27;)
					this.instance.currentItem.css({ top: &#x27;auto&#x27;, left: &#x27;auto&#x27; });

			} else {
				this.instance.cancelHelperRemoval = false; &#x2F;&#x2F;Remove the helper in the sortable instance
				this.instance._trigger(&quot;deactivate&quot;, event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data(&quot;draggable&quot;), that = this;

		var checkPos = function(o) {
			var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
			var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
			var itemHeight = o.height, itemWidth = o.width;
			var itemTop = o.top, itemLeft = o.left;

			return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
		};

		$.each(inst.sortables, function(i) {

			var innermostIntersecting = false;
			var thisSortable = this;
			&#x2F;&#x2F;Copy over some variables to allow calling the sortable&#x27;s native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function () {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if  (this != thisSortable
						&amp;&amp; this.instance._intersectsWith(this.instance.containerCache)
						&amp;&amp; $.ui.contains(thisSortable.instance.element[0], this.instance.element[0]))
						innermostIntersecting = false;
						return innermostIntersecting;
				});
			}


			if(innermostIntersecting) {
				&#x2F;&#x2F;If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					&#x2F;&#x2F;Now we fake the start of dragging for the sortable instance,
					&#x2F;&#x2F;by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					&#x2F;&#x2F;We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn&#x27;t create a new one)
					this.instance.currentItem = $(that).clone().removeAttr(&#x27;id&#x27;).appendTo(this.instance.element).data(&quot;sortable-item&quot;, true);
					this.instance.options._helper = this.instance.options.helper; &#x2F;&#x2F;Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					&#x2F;&#x2F;Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger(&quot;toSortable&quot;, event);
					inst.dropped = this.instance.element; &#x2F;&#x2F;draggable revert needs that
					&#x2F;&#x2F;hack so receive&#x2F;update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				&#x2F;&#x2F;Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) this.instance._mouseDrag(event);

			} else {

				&#x2F;&#x2F;If it doesn&#x27;t intersect with the sortable, and it intersected before,
				&#x2F;&#x2F;we fake the drag stop of the sortable, but make sure it doesn&#x27;t remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					&#x2F;&#x2F;Prevent reverting on this forced stop
					this.instance.options.revert = false;

					&#x2F;&#x2F; The out event needs to be triggered independently
					this.instance._trigger(&#x27;out&#x27;, event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					&#x2F;&#x2F;Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it&#x27;s original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) this.instance.placeholder.remove();

					inst._trigger(&quot;fromSortable&quot;, event);
					inst.dropped = false; &#x2F;&#x2F;draggable revert needs that
				}

			};

		});

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;cursor&quot;, {
	start: function(event, ui) {
		var t = $(&#x27;body&#x27;), o = $(this).data(&#x27;draggable&#x27;).options;
		if (t.css(&quot;cursor&quot;)) o._cursor = t.css(&quot;cursor&quot;);
		t.css(&quot;cursor&quot;, o.cursor);
	},
	stop: function(event, ui) {
		var o = $(this).data(&#x27;draggable&#x27;).options;
		if (o._cursor) $(&#x27;body&#x27;).css(&quot;cursor&quot;, o._cursor);
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;opacity&quot;, {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data(&#x27;draggable&#x27;).options;
		if(t.css(&quot;opacity&quot;)) o._opacity = t.css(&quot;opacity&quot;);
		t.css(&#x27;opacity&#x27;, o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data(&#x27;draggable&#x27;).options;
		if(o._opacity) $(ui.helper).css(&#x27;opacity&#x27;, o._opacity);
	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;scroll&quot;, {
	start: function(event, ui) {
		var i = $(this).data(&quot;draggable&quot;);
		if(i.scrollParent[0] != document &amp;&amp; i.scrollParent[0].tagName != &#x27;HTML&#x27;) i.overflowOffset = i.scrollParent.offset();
	},
	drag: function(event, ui) {

		var i = $(this).data(&quot;draggable&quot;), o = i.options, scrolled = false;

		if(i.scrollParent[0] != document &amp;&amp; i.scrollParent[0].tagName != &#x27;HTML&#x27;) {

			if(!o.axis || o.axis != &#x27;x&#x27;) {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY &lt; o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - i.overflowOffset.top &lt; o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
			}

			if(!o.axis || o.axis != &#x27;y&#x27;) {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX &lt; o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - i.overflowOffset.left &lt; o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
			}

		} else {

			if(!o.axis || o.axis != &#x27;x&#x27;) {
				if(event.pageY - $(document).scrollTop() &lt; o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) &lt; o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
			}

			if(!o.axis || o.axis != &#x27;y&#x27;) {
				if(event.pageX - $(document).scrollLeft() &lt; o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) &lt; o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
			}

		}

		if(scrolled !== false &amp;&amp; $.ui.ddmanager &amp;&amp; !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(i, event);

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;snap&quot;, {
	start: function(event, ui) {

		var i = $(this).data(&quot;draggable&quot;), o = i.options;
		i.snapElements = [];

		$(o.snap.constructor != String ? ( o.snap.items || &#x27;:data(draggable)&#x27; ) : o.snap).each(function() {
			var $t = $(this); var $o = $t.offset();
			if(this != i.element[0]) i.snapElements.push({
				item: this,
				width: $t.outerWidth(), height: $t.outerHeight(),
				top: $o.top, left: $o.left
			});
		});

	},
	drag: function(event, ui) {

		var inst = $(this).data(&quot;draggable&quot;), o = inst.options;
		var d = o.snapTolerance;

		var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (var i = inst.snapElements.length - 1; i &gt;= 0; i--){

			var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
				t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

			&#x2F;&#x2F;Yes, I know, this is insane ;)
			if(!((l-d &lt; x1 &amp;&amp; x1 &lt; r+d &amp;&amp; t-d &lt; y1 &amp;&amp; y1 &lt; b+d) || (l-d &lt; x1 &amp;&amp; x1 &lt; r+d &amp;&amp; t-d &lt; y2 &amp;&amp; y2 &lt; b+d) || (l-d &lt; x2 &amp;&amp; x2 &lt; r+d &amp;&amp; t-d &lt; y1 &amp;&amp; y1 &lt; b+d) || (l-d &lt; x2 &amp;&amp; x2 &lt; r+d &amp;&amp; t-d &lt; y2 &amp;&amp; y2 &lt; b+d))) {
				if(inst.snapElements[i].snapping) (inst.options.snap.release &amp;&amp; inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode != &#x27;inner&#x27;) {
				var ts = Math.abs(t - y2) &lt;= d;
				var bs = Math.abs(b - y1) &lt;= d;
				var ls = Math.abs(l - x2) &lt;= d;
				var rs = Math.abs(r - x1) &lt;= d;
				if(ts) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: b, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: r }).left - inst.margins.left;
			}

			var first = (ts || bs || ls || rs);

			if(o.snapMode != &#x27;outer&#x27;) {
				var ts = Math.abs(t - y1) &lt;= d;
				var bs = Math.abs(b - y2) &lt;= d;
				var ls = Math.abs(l - x1) &lt;= d;
				var rs = Math.abs(r - x2) &lt;= d;
				if(ts) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: t, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo(&quot;relative&quot;, { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: l }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo(&quot;relative&quot;, { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
			}

			if(!inst.snapElements[i].snapping &amp;&amp; (ts || bs || ls || rs || first))
				(inst.options.snap.snap &amp;&amp; inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		};

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;stack&quot;, {
	start: function(event, ui) {

		var o = $(this).data(&quot;draggable&quot;).options;

		var group = $.makeArray($(o.stack)).sort(function(a,b) {
			return (parseInt($(a).css(&quot;zIndex&quot;),10) || 0) - (parseInt($(b).css(&quot;zIndex&quot;),10) || 0);
		});
		if (!group.length) { return; }

		var min = parseInt(group[0].style.zIndex) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add(&quot;draggable&quot;, &quot;zIndex&quot;, {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data(&quot;draggable&quot;).options;
		if(t.css(&quot;zIndex&quot;)) o._zIndex = t.css(&quot;zIndex&quot;);
		t.css(&#x27;zIndex&#x27;, o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data(&quot;draggable&quot;).options;
		if(o._zIndex) $(ui.helper).css(&#x27;zIndex&#x27;, o._zIndex);
	}
});

})(jQuery);
(function( $, undefined ) {

$.widget(&quot;ui.droppable&quot;, {
	version: &quot;1.9.2&quot;,
	widgetEventPrefix: &quot;drop&quot;,
	options: {
		accept: &#x27;*&#x27;,
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: &#x27;default&#x27;,
		tolerance: &#x27;intersect&#x27;
	},
	_create: function() {

		var o = this.options, accept = o.accept;
		this.isover = 0; this.isout = 1;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		&#x2F;&#x2F;Store the droppable&#x27;s proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		&#x2F;&#x2F; Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses &amp;&amp; this.element.addClass(&quot;ui-droppable&quot;));

	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[this.options.scope];
		for ( var i = 0; i &lt; drop.length; i++ )
			if ( drop[i] == this )
				drop.splice(i, 1);

		this.element.removeClass(&quot;ui-droppable ui-droppable-disabled&quot;);
	},

	_setOption: function(key, value) {

		if(key == &#x27;accept&#x27;) {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.addClass(this.options.activeClass);
		(draggable &amp;&amp; this._trigger(&#x27;activate&#x27;, event, this.ui(draggable)));
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
		(draggable &amp;&amp; this._trigger(&#x27;deactivate&#x27;, event, this.ui(draggable)));
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; &#x2F;&#x2F; Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
			this._trigger(&#x27;over&#x27;, event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; &#x2F;&#x2F; Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger(&#x27;out&#x27;, event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; &#x2F;&#x2F; Bail if draggable and droppable are same element

		var childrenIntersection = false;
		this.element.find(&quot;:data(droppable)&quot;).not(&quot;.ui-draggable-dragging&quot;).each(function() {
			var inst = $.data(this, &#x27;droppable&#x27;);
			if(
				inst.options.greedy
				&amp;&amp; !inst.options.disabled
				&amp;&amp; inst.options.scope == draggable.options.scope
				&amp;&amp; inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
				&amp;&amp; $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) return false;

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger(&#x27;drop&#x27;, event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) return false;

	var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
	var l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case &#x27;fit&#x27;:
			return (l &lt;= x1 &amp;&amp; x2 &lt;= r
				&amp;&amp; t &lt;= y1 &amp;&amp; y2 &lt;= b);
			break;
		case &#x27;intersect&#x27;:
			return (l &lt; x1 + (draggable.helperProportions.width &#x2F; 2) &#x2F;&#x2F; Right Half
				&amp;&amp; x2 - (draggable.helperProportions.width &#x2F; 2) &lt; r &#x2F;&#x2F; Left Half
				&amp;&amp; t &lt; y1 + (draggable.helperProportions.height &#x2F; 2) &#x2F;&#x2F; Bottom Half
				&amp;&amp; y2 - (draggable.helperProportions.height &#x2F; 2) &lt; b ); &#x2F;&#x2F; Top Half
			break;
		case &#x27;pointer&#x27;:
			var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
			break;
		case &#x27;touch&#x27;:
			return (
					(y1 &gt;= t &amp;&amp; y1 &lt;= b) ||	&#x2F;&#x2F; Top edge touching
					(y2 &gt;= t &amp;&amp; y2 &lt;= b) ||	&#x2F;&#x2F; Bottom edge touching
					(y1 &lt; t &amp;&amp; y2 &gt; b)		&#x2F;&#x2F; Surrounded vertically
				) &amp;&amp; (
					(x1 &gt;= l &amp;&amp; x1 &lt;= r) ||	&#x2F;&#x2F; Left edge touching
					(x2 &gt;= l &amp;&amp; x2 &lt;= r) ||	&#x2F;&#x2F; Right edge touching
					(x1 &lt; l &amp;&amp; x2 &gt; r)		&#x2F;&#x2F; Surrounded horizontally
				);
			break;
		default:
			return false;
			break;
		}

};

&#x2F;*
	This manager tracks offsets of draggables and droppables
*&#x2F;
$.ui.ddmanager = {
	current: null,
	droppables: { &#x27;default&#x27;: [] },
	prepareOffsets: function(t, event) {

		var m = $.ui.ddmanager.droppables[t.options.scope] || [];
		var type = event ? event.type : null; &#x2F;&#x2F; workaround for #2317
		var list = (t.currentItem || t.element).find(&quot;:data(droppable)&quot;).andSelf();

		droppablesLoop: for (var i = 0; i &lt; m.length; i++) {

			if(m[i].options.disabled || (t &amp;&amp; !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue;	&#x2F;&#x2F;No disabled and non-accepted
			for (var j=0; j &lt; list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; &#x2F;&#x2F;Filter out elements in the current dragged item
			m[i].visible = m[i].element.css(&quot;display&quot;) != &quot;none&quot;; if(!m[i].visible) continue; 									&#x2F;&#x2F;If the element is not visible, continue

			if(type == &quot;mousedown&quot;) m[i]._activate.call(m[i], event); &#x2F;&#x2F;Activate the droppable if used directly from draggables

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) return;
			if (!this.options.disabled &amp;&amp; this.visible &amp;&amp; $.ui.intersect(draggable, this, this.options.tolerance))
				dropped = this._drop.call(this, event) || dropped;

			if (!this.options.disabled &amp;&amp; this.visible &amp;&amp; this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = 1; this.isover = 0;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		&#x2F;&#x2F;Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( &quot;body&quot; ).bind( &quot;scroll.droppable&quot;, function() {
			if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
		});
	},
	drag: function(draggable, event) {

		&#x2F;&#x2F;If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

		&#x2F;&#x2F;Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) return;
			var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

			var c = !intersects &amp;&amp; this.isover == 1 ? &#x27;isout&#x27; : (intersects &amp;&amp; this.isover == 0 ? &#x27;isover&#x27; : null);
			if(!c) return;

			var parentInstance;
			if (this.options.greedy) {
				&#x2F;&#x2F; find droppable parents with same scope
				var scope = this.options.scope;
				var parent = this.element.parents(&#x27;:data(droppable)&#x27;).filter(function () {
					return $.data(this, &#x27;droppable&#x27;).options.scope === scope;
				});

				if (parent.length) {
					parentInstance = $.data(parent[0], &#x27;droppable&#x27;);
					parentInstance.greedyChild = (c == &#x27;isover&#x27; ? 1 : 0);
				}
			}

			&#x2F;&#x2F; we just moved into a greedy child
			if (parentInstance &amp;&amp; c == &#x27;isover&#x27;) {
				parentInstance[&#x27;isover&#x27;] = 0;
				parentInstance[&#x27;isout&#x27;] = 1;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = 1; this[c == &#x27;isout&#x27; ? &#x27;isover&#x27; : &#x27;isout&#x27;] = 0;
			this[c == &quot;isover&quot; ? &quot;_over&quot; : &quot;_out&quot;].call(this, event);

			&#x2F;&#x2F; we just moved out of a greedy child
			if (parentInstance &amp;&amp; c == &#x27;isout&#x27;) {
				parentInstance[&#x27;isout&#x27;] = 0;
				parentInstance[&#x27;isover&#x27;] = 1;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( &quot;body&quot; ).unbind( &quot;scroll.droppable&quot; );
		&#x2F;&#x2F;Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
	}
};

})(jQuery);
(function( $, undefined ) {

$.widget(&quot;ui.resizable&quot;, $.ui.mouse, {
	version: &quot;1.9.2&quot;,
	widgetEventPrefix: &quot;resize&quot;,
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: &quot;slow&quot;,
		animateEasing: &quot;swing&quot;,
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: &quot;e,s,se&quot;,
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		zIndex: 1000
	},
	_create: function() {

		var that = this, o = this.options;
		this.element.addClass(&quot;ui-resizable&quot;);

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || &#x27;ui-resizable-helper&#x27; : null
		});

		&#x2F;&#x2F;Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(&#x2F;canvas|textarea|input|select|button|img&#x2F;i)) {

			&#x2F;&#x2F;Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$(&#x27;&lt;div class=&quot;ui-wrapper&quot; style=&quot;overflow: hidden;&quot;&gt;&lt;&#x2F;div&gt;&#x27;).css({
					position: this.element.css(&#x27;position&#x27;),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css(&#x27;top&#x27;),
					left: this.element.css(&#x27;left&#x27;)
				})
			);

			&#x2F;&#x2F;Overwrite the original this.element
			this.element = this.element.parent().data(
				&quot;resizable&quot;, this.element.data(&#x27;resizable&#x27;)
			);

			this.elementIsWrapper = true;

			&#x2F;&#x2F;Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css(&quot;marginLeft&quot;), marginTop: this.originalElement.css(&quot;marginTop&quot;), marginRight: this.originalElement.css(&quot;marginRight&quot;), marginBottom: this.originalElement.css(&quot;marginBottom&quot;) });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			&#x2F;&#x2F;Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css(&#x27;resize&#x27;);
			this.originalElement.css(&#x27;resize&#x27;, &#x27;none&#x27;);

			&#x2F;&#x2F;Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: &#x27;static&#x27;, zoom: 1, display: &#x27;block&#x27; }));

			&#x2F;&#x2F; avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css(&#x27;margin&#x27;) });

			&#x2F;&#x2F; fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$(&#x27;.ui-resizable-handle&#x27;, this.element).length ? &quot;e,s,se&quot; : { n: &#x27;.ui-resizable-n&#x27;, e: &#x27;.ui-resizable-e&#x27;, s: &#x27;.ui-resizable-s&#x27;, w: &#x27;.ui-resizable-w&#x27;, se: &#x27;.ui-resizable-se&#x27;, sw: &#x27;.ui-resizable-sw&#x27;, ne: &#x27;.ui-resizable-ne&#x27;, nw: &#x27;.ui-resizable-nw&#x27; });
		if(this.handles.constructor == String) {

			if(this.handles == &#x27;all&#x27;) this.handles = &#x27;n,e,s,w,se,sw,ne,nw&#x27;;
			var n = this.handles.split(&quot;,&quot;); this.handles = {};

			for(var i = 0; i &lt; n.length; i++) {

				var handle = $.trim(n[i]), hname = &#x27;ui-resizable-&#x27;+handle;
				var axis = $(&#x27;&lt;div class=&quot;ui-resizable-handle &#x27; + hname + &#x27;&quot;&gt;&lt;&#x2F;div&gt;&#x27;);

				&#x2F;&#x2F; Apply zIndex to all handles - see #7960
				axis.css({ zIndex: o.zIndex });

				&#x2F;&#x2F;TODO : What&#x27;s going on here?
				if (&#x27;se&#x27; == handle) {
					axis.addClass(&#x27;ui-icon ui-icon-gripsmall-diagonal-se&#x27;);
				};

				&#x2F;&#x2F;Insert into internal handles object and append to element
				this.handles[handle] = &#x27;.ui-resizable-&#x27;+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			target = target || this.element;

			for(var i in this.handles) {

				if(this.handles[i].constructor == String)
					this.handles[i] = $(this.handles[i], this.element).show();

				&#x2F;&#x2F;Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper &amp;&amp; this.originalElement[0].nodeName.match(&#x2F;textarea|input|select|button&#x2F;i)) {

					var axis = $(this.handles[i], this.element), padWrapper = 0;

					&#x2F;&#x2F;Checking the correct pad and border
					padWrapper = &#x2F;sw|ne|nw|se|n|s&#x2F;.test(i) ? axis.outerHeight() : axis.outerWidth();

					&#x2F;&#x2F;The padding type i have to apply...
					var padPos = [ &#x27;padding&#x27;,
						&#x2F;ne|nw|n&#x2F;.test(i) ? &#x27;Top&#x27; :
						&#x2F;se|sw|s&#x2F;.test(i) ? &#x27;Bottom&#x27; :
						&#x2F;^e$&#x2F;.test(i) ? &#x27;Right&#x27; : &#x27;Left&#x27; ].join(&quot;&quot;);

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				&#x2F;&#x2F;TODO: What&#x27;s that good for? There&#x27;s not anything to be executed left
				if(!$(this.handles[i]).length)
					continue;

			}
		};

		&#x2F;&#x2F;TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $(&#x27;.ui-resizable-handle&#x27;, this.element)
			.disableSelection();

		&#x2F;&#x2F;Matching axis name
		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className)
					var axis = this.className.match(&#x2F;ui-resizable-(se|sw|ne|nw|n|e|s|w)&#x2F;i);
				&#x2F;&#x2F;Axis, default = se
				that.axis = axis &amp;&amp; axis[1] ? axis[1] : &#x27;se&#x27;;
			}
		});

		&#x2F;&#x2F;If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass(&quot;ui-resizable-autohide&quot;)
				.mouseenter(function() {
					if (o.disabled) return;
					$(this).removeClass(&quot;ui-resizable-autohide&quot;);
					that._handles.show();
				})
				.mouseleave(function(){
					if (o.disabled) return;
					if (!that.resizing) {
						$(this).addClass(&quot;ui-resizable-autohide&quot;);
						that._handles.hide();
					}
				});
		}

		&#x2F;&#x2F;Initialize the mouse interaction
		this._mouseInit();

	},

	_destroy: function() {

		this._mouseDestroy();

		var _destroy = function(exp) {
			$(exp).removeClass(&quot;ui-resizable ui-resizable-disabled ui-resizable-resizing&quot;)
				.removeData(&quot;resizable&quot;).removeData(&quot;ui-resizable&quot;).unbind(&quot;.resizable&quot;).find(&#x27;.ui-resizable-handle&#x27;).remove();
		};

		&#x2F;&#x2F;TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			var wrapper = this.element;
			this.originalElement.css({
				position: wrapper.css(&#x27;position&#x27;),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css(&#x27;top&#x27;),
				left: wrapper.css(&#x27;left&#x27;)
			}).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css(&#x27;resize&#x27;, this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var handle = false;
		for (var i in this.handles) {
			if ($(this.handles[i])[0] == event.target) {
				handle = true;
			}
		}

		return !this.options.disabled &amp;&amp; handle;
	},

	_mouseStart: function(event) {

		var o = this.options, iniPos = this.element.position(), el = this.element;

		this.resizing = true;
		this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

		&#x2F;&#x2F; bugfix for http:&#x2F;&#x2F;dev.jquery.com&#x2F;ticket&#x2F;1749
		if (el.is(&#x27;.ui-draggable&#x27;) || (&#x2F;absolute&#x2F;).test(el.css(&#x27;position&#x27;))) {
			el.css({ position: &#x27;absolute&#x27;, top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		var curleft = num(this.helper.css(&#x27;left&#x27;)), curtop = num(this.helper.css(&#x27;top&#x27;));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		&#x2F;&#x2F;Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		&#x2F;&#x2F;Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio == &#x27;number&#x27;) ? o.aspectRatio : ((this.originalSize.width &#x2F; this.originalSize.height) || 1);

		var cursor = $(&#x27;.ui-resizable-&#x27; + this.axis).css(&#x27;cursor&#x27;);
		$(&#x27;body&#x27;).css(&#x27;cursor&#x27;, cursor == &#x27;auto&#x27; ? this.axis + &#x27;-resize&#x27; : cursor);

		el.addClass(&quot;ui-resizable-resizing&quot;);
		this._propagate(&quot;start&quot;, event);
		return true;
	},

	_mouseDrag: function(event) {

		&#x2F;&#x2F;Increase performance, avoid regex
		var el = this.helper, o = this.options, props = {},
			that = this, smp = this.originalMousePosition, a = this.axis;

		var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
		var trigger = this._change[a];
		if (!trigger) return false;

		&#x2F;&#x2F; Calculate the attrs that will be change
		var data = trigger.apply(this, [event, dx, dy]);

		&#x2F;&#x2F; Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey)
			data = this._updateRatio(data, event);

		data = this._respectSize(data, event);

		&#x2F;&#x2F; plugins callbacks need to be called first
		this._propagate(&quot;resize&quot;, event);

		el.css({
			top: this.position.top + &quot;px&quot;, left: this.position.left + &quot;px&quot;,
			width: this.size.width + &quot;px&quot;, height: this.size.height + &quot;px&quot;
		});

		if (!this._helper &amp;&amp; this._proportionallyResizeElements.length)
			this._proportionallyResize();

		this._updateCache(data);

		&#x2F;&#x2F; calling the user callback at the end
		this._trigger(&#x27;resize&#x27;, event, this.ui());

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var o = this.options, that = this;

		if(this._helper) {
			var pr = this._proportionallyResizeElements, ista = pr.length &amp;&amp; (&#x2F;textarea&#x2F;i).test(pr[0].nodeName),
				soffseth = ista &amp;&amp; $.ui.hasScroll(pr[0], &#x27;left&#x27;) &#x2F;* TODO - jump height *&#x2F; ? 0 : that.sizeDiff.height,
				soffsetw = ista ? 0 : that.sizeDiff.width;

			var s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) },
				left = (parseInt(that.element.css(&#x27;left&#x27;), 10) + (that.position.left - that.originalPosition.left)) || null,
				top = (parseInt(that.element.css(&#x27;top&#x27;), 10) + (that.position.top - that.originalPosition.top)) || null;

			if (!o.animate)
				this.element.css($.extend(s, { top: top, left: left }));

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper &amp;&amp; !o.animate) this._proportionallyResize();
		}

		$(&#x27;body&#x27;).css(&#x27;cursor&#x27;, &#x27;auto&#x27;);

		this.element.removeClass(&quot;ui-resizable-resizing&quot;);

		this._propagate(&quot;stop&quot;, event);

		if (this._helper) this.helper.remove();
		return false;

	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;

		b = {
			minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if(this._aspectRatio || forceAspectRatio) {
			&#x2F;&#x2F; We want to create an enclosing box whose aspect ration is the requested one
			&#x2F;&#x2F; First, compute the &quot;projected&quot; size for each dimension based on the aspect ratio and other dimension
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth &#x2F; this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth &#x2F; this.aspectRatio;

			if(pMinWidth &gt; b.minWidth) b.minWidth = pMinWidth;
			if(pMinHeight &gt; b.minHeight) b.minHeight = pMinHeight;
			if(pMaxWidth &lt; b.maxWidth) b.maxWidth = pMaxWidth;
			if(pMaxHeight &lt; b.maxHeight) b.maxHeight = pMaxHeight;
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		var o = this.options;
		this.offset = this.helper.offset();
		if (isNumber(data.left)) this.position.left = data.left;
		if (isNumber(data.top)) this.position.top = data.top;
		if (isNumber(data.height)) this.size.height = data.height;
		if (isNumber(data.width)) this.size.width = data.width;
	},

	_updateRatio: function(data, event) {

		var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

		if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);
		else if (isNumber(data.width)) data.height = (data.width &#x2F; this.aspectRatio);

		if (a == &#x27;sw&#x27;) {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a == &#x27;nw&#x27;) {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function(data, event) {

		var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
				ismaxw = isNumber(data.width) &amp;&amp; o.maxWidth &amp;&amp; (o.maxWidth &lt; data.width), ismaxh = isNumber(data.height) &amp;&amp; o.maxHeight &amp;&amp; (o.maxHeight &lt; data.height),
					isminw = isNumber(data.width) &amp;&amp; o.minWidth &amp;&amp; (o.minWidth &gt; data.width), isminh = isNumber(data.height) &amp;&amp; o.minHeight &amp;&amp; (o.minHeight &gt; data.height);

		if (isminw) data.width = o.minWidth;
		if (isminh) data.height = o.minHeight;
		if (ismaxw) data.width = o.maxWidth;
		if (ismaxh) data.height = o.maxHeight;

		var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
		var cw = &#x2F;sw|nw|w&#x2F;.test(a), ch = &#x2F;nw|ne|n&#x2F;.test(a);

		if (isminw &amp;&amp; cw) data.left = dw - o.minWidth;
		if (ismaxw &amp;&amp; cw) data.left = dw - o.maxWidth;
		if (isminh &amp;&amp; ch)	data.top = dh - o.minHeight;
		if (ismaxh &amp;&amp; ch)	data.top = dh - o.maxHeight;

		&#x2F;&#x2F; fixing jump error on top&#x2F;left - bug #2330
		var isNotwh = !data.width &amp;&amp; !data.height;
		if (isNotwh &amp;&amp; !data.left &amp;&amp; data.top) data.top = null;
		else if (isNotwh &amp;&amp; !data.top &amp;&amp; data.left) data.left = null;

		return data;
	},

	_proportionallyResize: function() {

		var o = this.options;
		if (!this._proportionallyResizeElements.length) return;
		var element = this.helper || this.element;

		for (var i=0; i &lt; this._proportionallyResizeElements.length; i++) {

			var prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				var b = [prel.css(&#x27;borderTopWidth&#x27;), prel.css(&#x27;borderRightWidth&#x27;), prel.css(&#x27;borderBottomWidth&#x27;), prel.css(&#x27;borderLeftWidth&#x27;)],
					p = [prel.css(&#x27;paddingTop&#x27;), prel.css(&#x27;paddingRight&#x27;), prel.css(&#x27;paddingBottom&#x27;), prel.css(&#x27;paddingLeft&#x27;)];

				this.borderDif = $.map(b, function(v, i) {
					var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
					return border + padding;
				});
			}

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		};

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $(&#x27;&lt;div style=&quot;overflow:hidden;&quot;&gt;&lt;&#x2F;div&gt;&#x27;);

			&#x2F;&#x2F; fix ie6 offset TODO: This seems broken
			var ie6offset = ($.ui.ie6 ? 1 : 0),
			pxyoffset = ( $.ui.ie6 ? 2 : -1 );

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() + pxyoffset,
				height: this.element.outerHeight() + pxyoffset,
				position: &#x27;absolute&#x27;,
				left: this.elementOffset.left - ie6offset +&#x27;px&#x27;,
				top: this.elementOffset.top - ie6offset +&#x27;px&#x27;,
				zIndex: ++o.zIndex &#x2F;&#x2F;TODO: Don&#x27;t modify option
			});

			this.helper
				.appendTo(&quot;body&quot;)
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx, dy) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n != &quot;resize&quot; &amp;&amp; this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

&#x2F;*
 * Resizable Extensions
 *&#x2F;

$.ui.plugin.add(&quot;resizable&quot;, &quot;alsoResize&quot;, {

	start: function (event, ui) {
		var that = $(this).data(&quot;resizable&quot;), o = that.options;

		var _store = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				el.data(&quot;resizable-alsoresize&quot;, {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css(&#x27;left&#x27;), 10), top: parseInt(el.css(&#x27;top&#x27;), 10)
				});
			});
		};

		if (typeof(o.alsoResize) == &#x27;object&#x27; &amp;&amp; !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var that = $(this).data(&quot;resizable&quot;), o = that.options, os = that.originalSize, op = that.originalPosition;

		var delta = {
			height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
			top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
		},

		_alsoResize = function (exp, c) {
			$(exp).each(function() {
				var el = $(this), start = $(this).data(&quot;resizable-alsoresize&quot;), style = {},
					css = c &amp;&amp; c.length ? c : el.parents(ui.originalElement[0]).length ? [&#x27;width&#x27;, &#x27;height&#x27;] : [&#x27;width&#x27;, &#x27;height&#x27;, &#x27;top&#x27;, &#x27;left&#x27;];

				$.each(css, function (i, prop) {
					var sum = (start[prop]||0) + (delta[prop]||0);
					if (sum &amp;&amp; sum &gt;= 0)
						style[prop] = sum || null;
				});

				el.css(style);
			});
		};

		if (typeof(o.alsoResize) == &#x27;object&#x27; &amp;&amp; !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function (event, ui) {
		$(this).removeData(&quot;resizable-alsoresize&quot;);
	}
});

$.ui.plugin.add(&quot;resizable&quot;, &quot;animate&quot;, {

	stop: function(event, ui) {
		var that = $(this).data(&quot;resizable&quot;), o = that.options;

		var pr = that._proportionallyResizeElements, ista = pr.length &amp;&amp; (&#x2F;textarea&#x2F;i).test(pr[0].nodeName),
					soffseth = ista &amp;&amp; $.ui.hasScroll(pr[0], &#x27;left&#x27;) &#x2F;* TODO - jump height *&#x2F; ? 0 : that.sizeDiff.height,
						soffsetw = ista ? 0 : that.sizeDiff.width;

		var style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
					left = (parseInt(that.element.css(&#x27;left&#x27;), 10) + (that.position.left - that.originalPosition.left)) || null,
						top = (parseInt(that.element.css(&#x27;top&#x27;), 10) + (that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top &amp;&amp; left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css(&#x27;width&#x27;), 10),
						height: parseInt(that.element.css(&#x27;height&#x27;), 10),
						top: parseInt(that.element.css(&#x27;top&#x27;), 10),
						left: parseInt(that.element.css(&#x27;left&#x27;), 10)
					};

					if (pr &amp;&amp; pr.length) $(pr[0]).css({ width: data.width, height: data.height });

					&#x2F;&#x2F; propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate(&quot;resize&quot;, event);

				}
			}
		);
	}

});

$.ui.plugin.add(&quot;resizable&quot;, &quot;containment&quot;, {

	start: function(event, ui) {
		var that = $(this).data(&quot;resizable&quot;), o = that.options, el = that.element;
		var oc = o.containment,	ce = (oc instanceof $) ? oc.get(0) : (&#x2F;parent&#x2F;.test(oc)) ? el.parent().get(0) : oc;
		if (!ce) return;

		that.containerElement = $(ce);

		if (&#x2F;document&#x2F;.test(oc) || oc == document) {
			that.containerOffset = { left: 0, top: 0 };
			that.containerPosition = { left: 0, top: 0 };

			that.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		&#x2F;&#x2F; i&#x27;m a node, so compute top, left, right, bottom
		else {
			var element = $(ce), p = [];
			$([ &quot;Top&quot;, &quot;Right&quot;, &quot;Left&quot;, &quot;Bottom&quot; ]).each(function(i, name) { p[i] = num(element.css(&quot;padding&quot; + name)); });

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			var co = that.containerOffset, ch = that.containerSize.height,	cw = that.containerSize.width,
						width = ($.ui.hasScroll(ce, &quot;left&quot;) ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			that.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function(event, ui) {
		var that = $(this).data(&quot;resizable&quot;), o = that.options,
				ps = that.containerSize, co = that.containerOffset, cs = that.size, cp = that.position,
				pRatio = that._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = that.containerElement;

		if (ce[0] != document &amp;&amp; (&#x2F;static&#x2F;).test(ce.css(&#x27;position&#x27;))) cop = co;

		if (cp.left &lt; (that._helper ? co.left : 0)) {
			that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
			if (pRatio) that.size.height = that.size.width &#x2F; that.aspectRatio;
			that.position.left = o.helper ? co.left : 0;
		}

		if (cp.top &lt; (that._helper ? co.top : 0)) {
			that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
			if (pRatio) that.size.width = that.size.height * that.aspectRatio;
			that.position.top = that._helper ? co.top : 0;
		}

		that.offset.left = that.parentData.left+that.position.left;
		that.offset.top = that.parentData.top+that.position.top;

		var woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width ),
					hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );

		var isParent = that.containerElement.get(0) == that.element.parent().get(0),
			isOffsetRelative = &#x2F;relative|absolute&#x2F;.test(that.containerElement.css(&#x27;position&#x27;));

		if(isParent &amp;&amp; isOffsetRelative) woset -= that.parentData.left;

		if (woset + that.size.width &gt;= that.parentData.width) {
			that.size.width = that.parentData.width - woset;
			if (pRatio) that.size.height = that.size.width &#x2F; that.aspectRatio;
		}

		if (hoset + that.size.height &gt;= that.parentData.height) {
			that.size.height = that.parentData.height - hoset;
			if (pRatio) that.size.width = that.size.height * that.aspectRatio;
		}
	},

	stop: function(event, ui){
		var that = $(this).data(&quot;resizable&quot;), o = that.options, cp = that.position,
				co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement;

		var helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;

		if (that._helper &amp;&amp; !o.animate &amp;&amp; (&#x2F;relative&#x2F;).test(ce.css(&#x27;position&#x27;)))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

		if (that._helper &amp;&amp; !o.animate &amp;&amp; (&#x2F;static&#x2F;).test(ce.css(&#x27;position&#x27;)))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

	}
});

$.ui.plugin.add(&quot;resizable&quot;, &quot;ghost&quot;, {

	start: function(event, ui) {

		var that = $(this).data(&quot;resizable&quot;), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({ opacity: .25, display: &#x27;block&#x27;, position: &#x27;relative&#x27;, height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass(&#x27;ui-resizable-ghost&#x27;)
			.addClass(typeof o.ghost == &#x27;string&#x27; ? o.ghost : &#x27;&#x27;);

		that.ghost.appendTo(that.helper);

	},

	resize: function(event, ui){
		var that = $(this).data(&quot;resizable&quot;), o = that.options;
		if (that.ghost) that.ghost.css({ position: &#x27;relative&#x27;, height: that.size.height, width: that.size.width });
	},

	stop: function(event, ui){
		var that = $(this).data(&quot;resizable&quot;), o = that.options;
		if (that.ghost &amp;&amp; that.helper) that.helper.get(0).removeChild(that.ghost.get(0));
	}

});

$.ui.plugin.add(&quot;resizable&quot;, &quot;grid&quot;, {

	resize: function(event, ui) {
		var that = $(this).data(&quot;resizable&quot;), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, ratio = o._aspectRatio || event.shiftKey;
		o.grid = typeof o.grid == &quot;number&quot; ? [o.grid, o.grid] : o.grid;
		var ox = Math.round((cs.width - os.width) &#x2F; (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) &#x2F; (o.grid[1]||1)) * (o.grid[1]||1);

		if (&#x2F;^(se|s|e)$&#x2F;.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
		}
		else if (&#x2F;^(ne)$&#x2F;.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.top = op.top - oy;
		}
		else if (&#x2F;^(sw)$&#x2F;.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.left = op.left - ox;
		}
		else {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.top = op.top - oy;
			that.position.left = op.left - ox;
		}
	}

});

var num = function(v) {
	return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
	return !isNaN(parseInt(value, 10));
};

})(jQuery);
(function( $, undefined ) {

$.widget(&quot;ui.selectable&quot;, $.ui.mouse, {
	version: &quot;1.9.2&quot;,
	options: {
		appendTo: &#x27;body&#x27;,
		autoRefresh: true,
		distance: 0,
		filter: &#x27;*&#x27;,
		tolerance: &#x27;touch&#x27;
	},
	_create: function() {
		var that = this;

		this.element.addClass(&quot;ui-selectable&quot;);

		this.dragged = false;

		&#x2F;&#x2F; cache selectee children based on filter
		var selectees;
		this.refresh = function() {
			selectees = $(that.options.filter, that.element[0]);
			selectees.addClass(&quot;ui-selectee&quot;);
			selectees.each(function() {
				var $this = $(this);
				var pos = $this.offset();
				$.data(this, &quot;selectable-item&quot;, {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass(&#x27;ui-selected&#x27;),
					selecting: $this.hasClass(&#x27;ui-selecting&#x27;),
					unselecting: $this.hasClass(&#x27;ui-unselecting&#x27;)
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass(&quot;ui-selectee&quot;);

		this._mouseInit();

		this.helper = $(&quot;&lt;div class=&#x27;ui-selectable-helper&#x27;&gt;&lt;&#x2F;div&gt;&quot;);
	},

	_destroy: function() {
		this.selectees
			.removeClass(&quot;ui-selectee&quot;)
			.removeData(&quot;selectable-item&quot;);
		this.element
			.removeClass(&quot;ui-selectable ui-selectable-disabled&quot;);
		this._mouseDestroy();
	},

	_mouseStart: function(event) {
		var that = this;

		this.opos = [event.pageX, event.pageY];

		if (this.options.disabled)
			return;

		var options = this.options;

		this.selectees = $(options.filter, this.element[0]);

		this._trigger(&quot;start&quot;, event);

		$(options.appendTo).append(this.helper);
		&#x2F;&#x2F; position helper (lasso)
		this.helper.css({
			&quot;left&quot;: event.clientX,
			&quot;top&quot;: event.clientY,
			&quot;width&quot;: 0,
			&quot;height&quot;: 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter(&#x27;.ui-selected&#x27;).each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			selectee.startselected = true;
			if (!event.metaKey &amp;&amp; !event.ctrlKey) {
				selectee.$element.removeClass(&#x27;ui-selected&#x27;);
				selectee.selected = false;
				selectee.$element.addClass(&#x27;ui-unselecting&#x27;);
				selectee.unselecting = true;
				&#x2F;&#x2F; selectable UNSELECTING callback
				that._trigger(&quot;unselecting&quot;, event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().andSelf().each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			if (selectee) {
				var doSelect = (!event.metaKey &amp;&amp; !event.ctrlKey) || !selectee.$element.hasClass(&#x27;ui-selected&#x27;);
				selectee.$element
					.removeClass(doSelect ? &quot;ui-unselecting&quot; : &quot;ui-selected&quot;)
					.addClass(doSelect ? &quot;ui-selecting&quot; : &quot;ui-unselecting&quot;);
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				&#x2F;&#x2F; selectable (UN)SELECTING callback
				if (doSelect) {
					that._trigger(&quot;selecting&quot;, event, {
						selecting: selectee.element
					});
				} else {
					that._trigger(&quot;unselecting&quot;, event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {
		var that = this;
		this.dragged = true;

		if (this.options.disabled)
			return;

		var options = this.options;

		var x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
		if (x1 &gt; x2) { var tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 &gt; y2) { var tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

		this.selectees.each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			&#x2F;&#x2F;prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element == that.element[0])
				return;
			var hit = false;
			if (options.tolerance == &#x27;touch&#x27;) {
				hit = ( !(selectee.left &gt; x2 || selectee.right &lt; x1 || selectee.top &gt; y2 || selectee.bottom &lt; y1) );
			} else if (options.tolerance == &#x27;fit&#x27;) {
				hit = (selectee.left &gt; x1 &amp;&amp; selectee.right &lt; x2 &amp;&amp; selectee.top &gt; y1 &amp;&amp; selectee.bottom &lt; y2);
			}

			if (hit) {
				&#x2F;&#x2F; SELECT
				if (selectee.selected) {
					selectee.$element.removeClass(&#x27;ui-selected&#x27;);
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass(&#x27;ui-unselecting&#x27;);
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass(&#x27;ui-selecting&#x27;);
					selectee.selecting = true;
					&#x2F;&#x2F; selectable SELECTING callback
					that._trigger(&quot;selecting&quot;, event, {
						selecting: selectee.element
					});
				}
			} else {
				&#x2F;&#x2F; UNSELECT
				if (selectee.selecting) {
					if ((event.metaKey || event.ctrlKey) &amp;&amp; selectee.startselected) {
						selectee.$element.removeClass(&#x27;ui-selecting&#x27;);
						selectee.selecting = false;
						selectee.$element.addClass(&#x27;ui-selected&#x27;);
						selectee.selected = true;
					} else {
						selectee.$element.removeClass(&#x27;ui-selecting&#x27;);
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass(&#x27;ui-unselecting&#x27;);
							selectee.unselecting = true;
						}
						&#x2F;&#x2F; selectable UNSELECTING callback
						that._trigger(&quot;unselecting&quot;, event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey &amp;&amp; !event.ctrlKey &amp;&amp; !selectee.startselected) {
						selectee.$element.removeClass(&#x27;ui-selected&#x27;);
						selectee.selected = false;

						selectee.$element.addClass(&#x27;ui-unselecting&#x27;);
						selectee.unselecting = true;
						&#x2F;&#x2F; selectable UNSELECTING callback
						that._trigger(&quot;unselecting&quot;, event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var that = this;

		this.dragged = false;

		var options = this.options;

		$(&#x27;.ui-unselecting&#x27;, this.element[0]).each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			selectee.$element.removeClass(&#x27;ui-unselecting&#x27;);
			selectee.unselecting = false;
			selectee.startselected = false;
			that._trigger(&quot;unselected&quot;, event, {
				unselected: selectee.element
			});
		});
		$(&#x27;.ui-selecting&#x27;, this.element[0]).each(function() {
			var selectee = $.data(this, &quot;selectable-item&quot;);
			selectee.$element.removeClass(&#x27;ui-selecting&#x27;).addClass(&#x27;ui-selected&#x27;);
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			that._trigger(&quot;selected&quot;, event, {
				selected: selectee.element
			});
		});
		this._trigger(&quot;stop&quot;, event);

		this.helper.remove();

		return false;
	}

});

})(jQuery);
(function( $, undefined ) {

$.widget(&quot;ui.sortable&quot;, $.ui.mouse, {
	version: &quot;1.9.2&quot;,
	widgetEventPrefix: &quot;sort&quot;,
	ready: false,
	options: {
		appendTo: &quot;parent&quot;,
		axis: false,
		connectWith: false,
		containment: false,
		cursor: &#x27;auto&#x27;,
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: &quot;original&quot;,
		items: &#x27;&gt; *&#x27;,
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: &quot;default&quot;,
		tolerance: &quot;intersect&quot;,
		zIndex: 1000
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass(&quot;ui-sortable&quot;);

		&#x2F;&#x2F;Get the items
		this.refresh();

		&#x2F;&#x2F;Let&#x27;s determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === &#x27;x&#x27; || (&#x2F;left|right&#x2F;).test(this.items[0].item.css(&#x27;float&#x27;)) || (&#x2F;inline|table-cell&#x2F;).test(this.items[0].item.css(&#x27;display&#x27;)) : false;

		&#x2F;&#x2F;Let&#x27;s determine the parent&#x27;s offset
		this.offset = this.element.offset();

		&#x2F;&#x2F;Initialize mouse events for interaction
		this._mouseInit();

		&#x2F;&#x2F;We&#x27;re ready to go
		this.ready = true

	},

	_destroy: function() {
		this.element
			.removeClass(&quot;ui-sortable ui-sortable-disabled&quot;);
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i &gt;= 0; i-- )
			this.items[i].item.removeData(this.widgetName + &quot;-item&quot;);

		return this;
	},

	_setOption: function(key, value){
		if ( key === &quot;disabled&quot; ) {
			this.options[ key ] = value;

			this.widget().toggleClass( &quot;ui-sortable-disabled&quot;, !!value );
		} else {
			&#x2F;&#x2F; Don&#x27;t call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {
		var that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type == &#x27;static&#x27;) return false;

		&#x2F;&#x2F;We have to refresh the items data once first
		this._refreshItems(event);

		&#x2F;&#x2F;Find out if the clicked node (or one of its parents) is a actual item in this.items
		var currentItem = null, nodes = $(event.target).parents().each(function() {
			if($.data(this, that.widgetName + &#x27;-item&#x27;) == that) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + &#x27;-item&#x27;) == that) currentItem = $(event.target);

		if(!currentItem) return false;
		if(this.options.handle &amp;&amp; !overrideHandle) {
			var validHandle = false;

			$(this.options.handle, currentItem).find(&quot;*&quot;).andSelf().each(function() { if(this == event.target) validHandle = true; });
			if(!validHandle) return false;
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var o = this.options;
		this.currentContainer = this;

		&#x2F;&#x2F;We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		&#x2F;&#x2F;Create and append the visible helper
		this.helper = this._createHelper(event);

		&#x2F;&#x2F;Cache the helper size
		this._cacheHelperProportions();

		&#x2F;*
		 * - Position generation -
		 * This block generates everything position related - it&#x27;s the core of draggables.
		 *&#x2F;

		&#x2F;&#x2F;Cache the margins of the original element
		this._cacheMargins();

		&#x2F;&#x2F;Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		&#x2F;&#x2F;The element&#x27;s absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { &#x2F;&#x2F;Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() &#x2F;&#x2F;This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		&#x2F;&#x2F; Only after we got the offset, we can change the helper&#x27;s position to absolute
		&#x2F;&#x2F; TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css(&quot;position&quot;, &quot;absolute&quot;);
		this.cssPosition = this.helper.css(&quot;position&quot;);

		&#x2F;&#x2F;Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		&#x2F;&#x2F;Adjust the mouse offset relative to the helper if &#x27;cursorAt&#x27; is supplied
		(o.cursorAt &amp;&amp; this._adjustOffsetFromHelper(o.cursorAt));

		&#x2F;&#x2F;Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		&#x2F;&#x2F;If the helper is not the original, hide the original so it&#x27;s not playing any role during the drag, won&#x27;t cause anything bad this way
		if(this.helper[0] != this.currentItem[0]) {
			this.currentItem.hide();
		}

		&#x2F;&#x2F;Create the placeholder
		this._createPlaceholder();

		&#x2F;&#x2F;Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		if(o.cursor) { &#x2F;&#x2F; cursor option
			if ($(&#x27;body&#x27;).css(&quot;cursor&quot;)) this._storedCursor = $(&#x27;body&#x27;).css(&quot;cursor&quot;);
			$(&#x27;body&#x27;).css(&quot;cursor&quot;, o.cursor);
		}

		if(o.opacity) { &#x2F;&#x2F; opacity option
			if (this.helper.css(&quot;opacity&quot;)) this._storedOpacity = this.helper.css(&quot;opacity&quot;);
			this.helper.css(&quot;opacity&quot;, o.opacity);
		}

		if(o.zIndex) { &#x2F;&#x2F; zIndex option
			if (this.helper.css(&quot;zIndex&quot;)) this._storedZIndex = this.helper.css(&quot;zIndex&quot;);
			this.helper.css(&quot;zIndex&quot;, o.zIndex);
		}

		&#x2F;&#x2F;Prepare scrolling
		if(this.scrollParent[0] != document &amp;&amp; this.scrollParent[0].tagName != &#x27;HTML&#x27;)
			this.overflowOffset = this.scrollParent.offset();

		&#x2F;&#x2F;Call callbacks
		this._trigger(&quot;start&quot;, event, this._uiHash());

		&#x2F;&#x2F;Recache the helper size
		if(!this._preserveHelperProportions)
			this._cacheHelperProportions();


		&#x2F;&#x2F;Post &#x27;activate&#x27; events to possible containers
		if(!noActivation) {
			 for (var i = this.containers.length - 1; i &gt;= 0; i--) { this.containers[i]._trigger(&quot;activate&quot;, event, this._uiHash(this)); }
		}

		&#x2F;&#x2F;Prepare possible droppables
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		if ($.ui.ddmanager &amp;&amp; !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.dragging = true;

		this.helper.addClass(&quot;ui-sortable-helper&quot;);
		this._mouseDrag(event); &#x2F;&#x2F;Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {

		&#x2F;&#x2F;Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		&#x2F;&#x2F;Do scrolling
		if(this.options.scroll) {
			var o = this.options, scrolled = false;
			if(this.scrollParent[0] != document &amp;&amp; this.scrollParent[0].tagName != &#x27;HTML&#x27;) {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY &lt; o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - this.overflowOffset.top &lt; o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX &lt; o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - this.overflowOffset.left &lt; o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

			} else {

				if(event.pageY - $(document).scrollTop() &lt; o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) &lt; o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

				if(event.pageX - $(document).scrollLeft() &lt; o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) &lt; o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

			}

			if(scrolled !== false &amp;&amp; $.ui.ddmanager &amp;&amp; !o.dropBehaviour)
				$.ui.ddmanager.prepareOffsets(this, event);
		}

		&#x2F;&#x2F;Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo(&quot;absolute&quot;);

		&#x2F;&#x2F;Set the helper position
		if(!this.options.axis || this.options.axis != &quot;y&quot;) this.helper[0].style.left = this.position.left+&#x27;px&#x27;;
		if(!this.options.axis || this.options.axis != &quot;x&quot;) this.helper[0].style.top = this.position.top+&#x27;px&#x27;;

		&#x2F;&#x2F;Rearrange
		for (var i = this.items.length - 1; i &gt;= 0; i--) {

			&#x2F;&#x2F;Cache variables and intersection, continue if no intersection
			var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
			if (!intersection) continue;

			&#x2F;&#x2F; Only put the placeholder inside the current Container, skip all
			&#x2F;&#x2F; items form other containers. This works because when moving
			&#x2F;&#x2F; an item from one container to another the
			&#x2F;&#x2F; currentContainer is switched before the placeholder is moved.
			&#x2F;&#x2F;
			&#x2F;&#x2F; Without this moving items in &quot;sub-sortables&quot; can cause the placeholder to jitter
			&#x2F;&#x2F; beetween the outer and inner container.
			if (item.instance !== this.currentContainer) continue;

			if (itemElement != this.currentItem[0] &#x2F;&#x2F;cannot intersect with itself
				&amp;&amp;	this.placeholder[intersection == 1 ? &quot;next&quot; : &quot;prev&quot;]()[0] != itemElement &#x2F;&#x2F;no useless actions that have been done before
				&amp;&amp;	!$.contains(this.placeholder[0], itemElement) &#x2F;&#x2F;no action if the item moved is the parent of the item checked
				&amp;&amp; (this.options.type == &#x27;semi-dynamic&#x27; ? !$.contains(this.element[0], itemElement) : true)
				&#x2F;&#x2F;&amp;&amp; itemElement.parentNode == this.placeholder[0].parentNode &#x2F;&#x2F; only rearrange items within the same container
			) {

				this.direction = intersection == 1 ? &quot;down&quot; : &quot;up&quot;;

				if (this.options.tolerance == &quot;pointer&quot; || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger(&quot;change&quot;, event, this._uiHash());
				break;
			}
		}

		&#x2F;&#x2F;Post events to containers
		this._contactContainers(event);

		&#x2F;&#x2F;Interconnect with droppables
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		&#x2F;&#x2F;Call callbacks
		this._trigger(&#x27;sort&#x27;, event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) return;

		&#x2F;&#x2F;If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager &amp;&amp; !this.options.dropBehaviour)
			$.ui.ddmanager.drop(this, event);

		if(this.options.revert) {
			var that = this;
			var cur = this.placeholder.offset();

			this.reverting = true;

			$(this.helper).animate({
				left: cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
				top: cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
			}, parseInt(this.options.revert, 10) || 500, function() {
				that._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper == &quot;original&quot;)
				this.currentItem.css(this._storedCSS).removeClass(&quot;ui-sortable-helper&quot;);
			else
				this.currentItem.show();

			&#x2F;&#x2F;Post deactivating events to containers
			for (var i = this.containers.length - 1; i &gt;= 0; i--){
				this.containers[i]._trigger(&quot;deactivate&quot;, null, this._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger(&quot;out&quot;, null, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			&#x2F;&#x2F;$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			if(this.options.helper != &quot;original&quot; &amp;&amp; this.helper &amp;&amp; this.helper[0].parentNode) this.helper.remove();

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o &amp;&amp; o.connected);
		var str = []; o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || &#x27;id&#x27;) || &#x27;&#x27;).match(o.expression || (&#x2F;(.+)[-=_](.+)&#x2F;));
			if(res) str.push((o.key || res[1]+&#x27;[]&#x27;)+&#x27;=&#x27;+(o.key &amp;&amp; o.expression ? res[1] : res[2]));
		});

		if(!str.length &amp;&amp; o.key) {
			str.push(o.key + &#x27;=&#x27;);
		}

		return str.join(&#x27;&amp;&#x27;);

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o &amp;&amp; o.connected);
		var ret = []; o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || &#x27;id&#x27;) || &#x27;&#x27;); });
		return ret;

	},

	&#x2F;* Be careful with the following core functions *&#x2F;
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height;

		var l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height;

		var dyClick = this.offset.click.top,
			dxClick = this.offset.click.left;

		var isOverElement = (y1 + dyClick) &gt; t &amp;&amp; (y1 + dyClick) &lt; b &amp;&amp; (x1 + dxClick) &gt; l &amp;&amp; (x1 + dxClick) &lt; r;

		if(	   this.options.tolerance == &quot;pointer&quot;
			|| this.options.forcePointerForContainers
			|| (this.options.tolerance != &quot;pointer&quot; &amp;&amp; this.helperProportions[this.floating ? &#x27;width&#x27; : &#x27;height&#x27;] &gt; item[this.floating ? &#x27;width&#x27; : &#x27;height&#x27;])
		) {
			return isOverElement;
		} else {

			return (l &lt; x1 + (this.helperProportions.width &#x2F; 2) &#x2F;&#x2F; Right Half
				&amp;&amp; x2 - (this.helperProportions.width &#x2F; 2) &lt; r &#x2F;&#x2F; Left Half
				&amp;&amp; t &lt; y1 + (this.helperProportions.height &#x2F; 2) &#x2F;&#x2F; Bottom Half
				&amp;&amp; y2 - (this.helperProportions.height &#x2F; 2) &lt; b ); &#x2F;&#x2F; Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === &#x27;x&#x27;) || $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === &#x27;y&#x27;) || $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight &amp;&amp; isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement)
			return false;

		return this.floating ?
			( ((horizontalDirection &amp;&amp; horizontalDirection == &quot;right&quot;) || verticalDirection == &quot;down&quot;) ? 2 : 1 )
			: ( verticalDirection &amp;&amp; (verticalDirection == &quot;down&quot; ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height&#x2F;2), item.height),
			isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width&#x2F;2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating &amp;&amp; horizontalDirection) {
			return ((horizontalDirection == &quot;right&quot; &amp;&amp; isOverRightHalf) || (horizontalDirection == &quot;left&quot; &amp;&amp; !isOverRightHalf));
		} else {
			return verticalDirection &amp;&amp; ((verticalDirection == &quot;down&quot; &amp;&amp; isOverBottomHalf) || (verticalDirection == &quot;up&quot; &amp;&amp; !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta != 0 &amp;&amp; (delta &gt; 0 ? &quot;down&quot; : &quot;up&quot;);
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta != 0 &amp;&amp; (delta &gt; 0 ? &quot;right&quot; : &quot;left&quot;);
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor == String
			? [options.connectWith]
			: options.connectWith;
	},

	_getItemsAsjQuery: function(connected) {

		var items = [];
		var queries = [];
		var connectWith = this._connectWith();

		if(connectWith &amp;&amp; connected) {
			for (var i = connectWith.length - 1; i &gt;= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j &gt;= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst &amp;&amp; inst != this &amp;&amp; !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(&quot;.ui-sortable-helper&quot;).not(&#x27;.ui-sortable-placeholder&#x27;), inst]);
					}
				};
			};
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(&quot;.ui-sortable-helper&quot;).not(&#x27;.ui-sortable-placeholder&#x27;), this]);

		for (var i = queries.length - 1; i &gt;= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		};

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(&quot;:data(&quot; + this.widgetName + &quot;-item)&quot;);

		this.items = $.grep(this.items, function (item) {
			for (var j=0; j &lt; list.length; j++) {
				if(list[j] == item.item[0])
					return false;
			};
			return true;
		});

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];
		var items = this.items;
		var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];
		var connectWith = this._connectWith();

		if(connectWith &amp;&amp; this.ready) { &#x2F;&#x2F;Shouldn&#x27;t be run the first time through due to massive slow-down
			for (var i = connectWith.length - 1; i &gt;= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j &gt;= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst &amp;&amp; inst != this &amp;&amp; !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				};
			};
		}

		for (var i = queries.length - 1; i &gt;= 0; i--) {
			var targetData = queries[i][1];
			var _queries = queries[i][0];

			for (var j=0, queriesLength = _queries.length; j &lt; queriesLength; j++) {
				var item = $(_queries[j]);

				item.data(this.widgetName + &#x27;-item&#x27;, targetData); &#x2F;&#x2F; Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			};
		};

	},

	refreshPositions: function(fast) {

		&#x2F;&#x2F;This has to be redone because due to the item being moved out&#x2F;into the offsetParent, the offsetParent&#x27;s position will change
		if(this.offsetParent &amp;&amp; this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		for (var i = this.items.length - 1; i &gt;= 0; i--){
			var item = this.items[i];

			&#x2F;&#x2F;We ignore calculating positions of all connected containers when we&#x27;re not over them
			if(item.instance != this.currentContainer &amp;&amp; this.currentContainer &amp;&amp; item.item[0] != this.currentItem[0])
				continue;

			var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			var p = t.offset();
			item.left = p.left;
			item.top = p.top;
		};

		if(this.options.custom &amp;&amp; this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (var i = this.containers.length - 1; i &gt;= 0; i--){
				var p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			};
		}

		return this;
	},

	_createPlaceholder: function(that) {
		that = that || this;
		var o = that.options;

		if(!o.placeholder || o.placeholder.constructor == String) {
			var className = o.placeholder;
			o.placeholder = {
				element: function() {

					var el = $(document.createElement(that.currentItem[0].nodeName))
						.addClass(className || that.currentItem[0].className+&quot; ui-sortable-placeholder&quot;)
						.removeClass(&quot;ui-sortable-helper&quot;)[0];

					if(!className)
						el.style.visibility = &quot;hidden&quot;;

					return el;
				},
				update: function(container, p) {

					&#x2F;&#x2F; 1. If a className is set as &#x27;placeholder option, we don&#x27;t force sizes - the class is responsible for that
					&#x2F;&#x2F; 2. The option &#x27;forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className &amp;&amp; !o.forcePlaceholderSize) return;

					&#x2F;&#x2F;If the element doesn&#x27;t have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css(&#x27;paddingTop&#x27;)||0, 10) - parseInt(that.currentItem.css(&#x27;paddingBottom&#x27;)||0, 10)); };
					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css(&#x27;paddingLeft&#x27;)||0, 10) - parseInt(that.currentItem.css(&#x27;paddingRight&#x27;)||0, 10)); };
				}
			};
		}

		&#x2F;&#x2F;Create the placeholder
		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

		&#x2F;&#x2F;Append it after the actual current item
		that.currentItem.after(that.placeholder);

		&#x2F;&#x2F;Update the size of the placeholder (TODO: Logic to fuzzy, see line 316&#x2F;317)
		o.placeholder.update(that, that.placeholder);

	},

	_contactContainers: function(event) {

		&#x2F;&#x2F; get innermost container that intersects with item
		var innermostContainer = null, innermostIndex = null;


		for (var i = this.containers.length - 1; i &gt;= 0; i--){

			&#x2F;&#x2F; never consider a container that&#x27;s located within the item itself
			if($.contains(this.currentItem[0], this.containers[i].element[0]))
				continue;

			if(this._intersectsWith(this.containers[i].containerCache)) {

				&#x2F;&#x2F; if we&#x27;ve already found a container and it&#x27;s more &quot;inner&quot; than this, then continue
				if(innermostContainer &amp;&amp; $.contains(this.containers[i].element[0], innermostContainer.element[0]))
					continue;

				innermostContainer = this.containers[i];
				innermostIndex = i;

			} else {
				&#x2F;&#x2F; container doesn&#x27;t intersect. trigger &quot;out&quot; event if necessary
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger(&quot;out&quot;, event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		&#x2F;&#x2F; if no intersecting containers found, return
		if(!innermostContainer) return;

		&#x2F;&#x2F; move the item into the container if it&#x27;s not there already
		if(this.containers.length === 1) {
			this.containers[innermostIndex]._trigger(&quot;over&quot;, event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} else {

			&#x2F;&#x2F;When entering a new container, we will find the item with the least distance and append our item near it
			var dist = 10000; var itemWithLeastDistance = null;
			var posProperty = this.containers[innermostIndex].floating ? &#x27;left&#x27; : &#x27;top&#x27;;
			var sizeProperty = this.containers[innermostIndex].floating ? &#x27;width&#x27; : &#x27;height&#x27;;
			var base = this.positionAbs[posProperty] + this.offset.click[posProperty];
			for (var j = this.items.length - 1; j &gt;= 0; j--) {
				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue;
				if(this.items[j].item[0] == this.currentItem[0]) continue;
				var cur = this.items[j].item.offset()[posProperty];
				var nearBottom = false;
				if(Math.abs(cur - base) &gt; Math.abs(cur + this.items[j][sizeProperty] - base)){
					nearBottom = true;
					cur += this.items[j][sizeProperty];
				}

				if(Math.abs(cur - base) &lt; dist) {
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
					this.direction = nearBottom ? &quot;up&quot;: &quot;down&quot;;
				}
			}

			if(!itemWithLeastDistance &amp;&amp; !this.options.dropOnEmpty) &#x2F;&#x2F;Check if dropOnEmpty is enabled
				return;

			this.currentContainer = this.containers[innermostIndex];
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger(&quot;change&quot;, event, this._uiHash());
			this.containers[innermostIndex]._trigger(&quot;change&quot;, event, this._uiHash(this));

			&#x2F;&#x2F;Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger(&quot;over&quot;, event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		}


	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == &#x27;clone&#x27; ? this.currentItem.clone() : this.currentItem);

		if(!helper.parents(&#x27;body&#x27;).length) &#x2F;&#x2F;Add the helper to the DOM if that didn&#x27;t happen already
			$(o.appendTo != &#x27;parent&#x27; ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

		if(helper[0] == this.currentItem[0])
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css(&quot;position&quot;), top: this.currentItem.css(&quot;top&quot;), left: this.currentItem.css(&quot;left&quot;) };

		if(helper[0].style.width == &#x27;&#x27; || o.forceHelperSize) helper.width(this.currentItem.width());
		if(helper[0].style.height == &#x27;&#x27; || o.forceHelperSize) helper.height(this.currentItem.height());

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == &#x27;string&#x27;) {
			obj = obj.split(&#x27; &#x27;);
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if (&#x27;left&#x27; in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if (&#x27;right&#x27; in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if (&#x27;top&#x27; in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if (&#x27;bottom&#x27; in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		&#x2F;&#x2F;Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		&#x2F;&#x2F; This is a special case where we need to modify a offset calculated on start, since the following happened:
		&#x2F;&#x2F; 1. The position of the helper is absolute, so it&#x27;s position is calculated based on the next positioned parent
		&#x2F;&#x2F; 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn&#x27;t the document, which means that
		&#x2F;&#x2F;    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == &#x27;absolute&#x27; &amp;&amp; this.scrollParent[0] != document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) &#x2F;&#x2F;This needs to be actually done for all browsers, since pageX&#x2F;pageY includes this information
		|| (this.offsetParent[0].tagName &amp;&amp; this.offsetParent[0].tagName.toLowerCase() == &#x27;html&#x27; &amp;&amp; $.ui.ie)) &#x2F;&#x2F;Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css(&quot;borderTopWidth&quot;),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css(&quot;borderLeftWidth&quot;),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == &quot;relative&quot;) {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css(&quot;top&quot;),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css(&quot;left&quot;),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css(&quot;marginLeft&quot;),10) || 0),
			top: (parseInt(this.currentItem.css(&quot;marginTop&quot;),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == &#x27;parent&#x27;) o.containment = this.helper[0].parentNode;
		if(o.containment == &#x27;document&#x27; || o.containment == &#x27;window&#x27;) this.containment = [
			0 - this.offset.relative.left - this.offset.parent.left,
			0 - this.offset.relative.top - this.offset.parent.top,
			$(o.containment == &#x27;document&#x27; ? document : window).width() - this.helperProportions.width - this.margins.left,
			($(o.containment == &#x27;document&#x27; ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(&#x2F;^(document|window|parent)$&#x2F;).test(o.containment)) {
			var ce = $(o.containment)[0];
			var co = $(o.containment).offset();
			var over = ($(ce).css(&quot;overflow&quot;) != &#x27;hidden&#x27;);

			this.containment = [
				co.left + (parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingLeft&quot;),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) + (parseInt($(ce).css(&quot;paddingTop&quot;),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css(&quot;borderLeftWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingRight&quot;),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css(&quot;borderTopWidth&quot;),10) || 0) - (parseInt($(ce).css(&quot;paddingBottom&quot;),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == &quot;absolute&quot; ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == &#x27;absolute&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (&#x2F;(html|body)&#x2F;i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	&#x2F;&#x2F; The absolute mouse position
				+ this.offset.relative.top * mod										&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				- ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																&#x2F;&#x2F; The absolute mouse position
				+ this.offset.relative.left * mod										&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				- ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == &#x27;absolute&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (&#x2F;(html|body)&#x2F;i).test(scroll[0].tagName);

		&#x2F;&#x2F; This is another very weird special case that only happens for relative elements:
		&#x2F;&#x2F; 1. If the css position is relative
		&#x2F;&#x2F; 2. and the scroll parent is the document or similar to the offset parent
		&#x2F;&#x2F; we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition == &#x27;relative&#x27; &amp;&amp; !(this.scrollParent[0] != document &amp;&amp; this.scrollParent[0] != this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		var pageX = event.pageX;
		var pageY = event.pageY;

		&#x2F;*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 *&#x2F;

		if(this.originalPosition) { &#x2F;&#x2F;If we are not dragging yet, we won&#x27;t check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left &lt; this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &lt; this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left &gt; this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top &gt; this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				var top = this.originalPageY + Math.round((pageY - this.originalPageY) &#x2F; o.grid[1]) * o.grid[1];
				pageY = this.containment ? (!(top - this.offset.click.top &lt; this.containment[1] || top - this.offset.click.top &gt; this.containment[3]) ? top : (!(top - this.offset.click.top &lt; this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = this.originalPageX + Math.round((pageX - this.originalPageX) &#x2F; o.grid[0]) * o.grid[0];
				pageX = this.containment ? (!(left - this.offset.click.left &lt; this.containment[0] || left - this.offset.click.left &gt; this.containment[2]) ? left : (!(left - this.offset.click.left &lt; this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																&#x2F;&#x2F; The absolute mouse position
				- this.offset.click.top													&#x2F;&#x2F; Click offset (relative to the element)
				- this.offset.relative.top												&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				+ ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																&#x2F;&#x2F; The absolute mouse position
				- this.offset.click.left												&#x2F;&#x2F; Click offset (relative to the element)
				- this.offset.relative.left												&#x2F;&#x2F; Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												&#x2F;&#x2F; The offsetParent&#x27;s offset without borders (offset + border)
				+ ( ( this.cssPosition == &#x27;fixed&#x27; ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == &#x27;down&#x27; ? i.item[0] : i.item[0].nextSibling));

		&#x2F;&#x2F;Various things done here to improve the performance:
		&#x2F;&#x2F; 1. we create a setTimeout, that calls refreshPositions
		&#x2F;&#x2F; 2. on the instance, we have a counter variable, that get&#x27;s higher after every append
		&#x2F;&#x2F; 3. on the local scope, we copy the counter variable, and check in the timeout, if it&#x27;s still the same
		&#x2F;&#x2F; 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay(function() {
			if(counter == this.counter) this.refreshPositions(!hardRefresh); &#x2F;&#x2F;Precompute after each DOM insertion, NOT on mousemove
		});

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		&#x2F;&#x2F; We delay all events that have to be triggered to after the point where the placeholder has been removed and
		&#x2F;&#x2F; everything else normalized again
		var delayedTriggers = [];

		&#x2F;&#x2F; We first have to update the dom position of the actual currentItem
		&#x2F;&#x2F; Note: don&#x27;t do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort &amp;&amp; this.currentItem.parent().length) this.placeholder.before(this.currentItem);
		this._noFinalSort = null;

		if(this.helper[0] == this.currentItem[0]) {
			for(var i in this._storedCSS) {
				if(this._storedCSS[i] == &#x27;auto&#x27; || this._storedCSS[i] == &#x27;static&#x27;) this._storedCSS[i] = &#x27;&#x27;;
			}
			this.currentItem.css(this._storedCSS).removeClass(&quot;ui-sortable-helper&quot;);
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside &amp;&amp; !noPropagation) delayedTriggers.push(function(event) { this._trigger(&quot;receive&quot;, event, this._uiHash(this.fromOutside)); });
		if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(&quot;.ui-sortable-helper&quot;)[0] || this.domPosition.parent != this.currentItem.parent()[0]) &amp;&amp; !noPropagation) delayedTriggers.push(function(event) { this._trigger(&quot;update&quot;, event, this._uiHash()); }); &#x2F;&#x2F;Trigger update callback if the DOM position has changed

		&#x2F;&#x2F; Check if the items Container has Changed and trigger appropriate
		&#x2F;&#x2F; events.
		if (this !== this.currentContainer) {
			if(!noPropagation) {
				delayedTriggers.push(function(event) { this._trigger(&quot;remove&quot;, event, this._uiHash()); });
				delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;receive&quot;, event, this._uiHash(this)); };  }).call(this, this.currentContainer));
				delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;update&quot;, event, this._uiHash(this));  }; }).call(this, this.currentContainer));
			}
		}


		&#x2F;&#x2F;Post events to containers
		for (var i = this.containers.length - 1; i &gt;= 0; i--){
			if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;deactivate&quot;, event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger(&quot;out&quot;, event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		&#x2F;&#x2F;Do what was originally in plugins
		if(this._storedCursor) $(&#x27;body&#x27;).css(&quot;cursor&quot;, this._storedCursor); &#x2F;&#x2F;Reset cursor
		if(this._storedOpacity) this.helper.css(&quot;opacity&quot;, this._storedOpacity); &#x2F;&#x2F;Reset opacity
		if(this._storedZIndex) this.helper.css(&quot;zIndex&quot;, this._storedZIndex == &#x27;auto&#x27; ? &#x27;&#x27; : this._storedZIndex); &#x2F;&#x2F;Reset z-index

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger(&quot;beforeStop&quot;, event, this._uiHash());
				for (var i=0; i &lt; delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; &#x2F;&#x2F;Trigger all delayed events
				this._trigger(&quot;stop&quot;, event, this._uiHash());
			}

			this.fromOutside = false;
			return false;
		}

		if(!noPropagation) this._trigger(&quot;beforeStop&quot;, event, this._uiHash());

		&#x2F;&#x2F;$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;

		if(!noPropagation) {
			for (var i=0; i &lt; delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; &#x2F;&#x2F;Trigger all delayed events
			this._trigger(&quot;stop&quot;, event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(_inst) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $([]),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

});

})(jQuery);
;(jQuery.effects || (function($, undefined) {

var backCompat = $.uiBackCompat !== false,
	&#x2F;&#x2F; prefix used for storing data on .data()
	dataSpace = &quot;ui-effects-&quot;;

$.effects = {
	effect: {}
};

&#x2F;*!
 * jQuery Color Animations v2.0.0
 * http:&#x2F;&#x2F;jquery.com&#x2F;
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http:&#x2F;&#x2F;jquery.org&#x2F;license
 *
 * Date: Mon Aug 13 13:41:02 2012 -0500
 *&#x2F;
(function( jQuery, undefined ) {

	var stepHooks = &quot;backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor&quot;.split(&quot; &quot;),

	&#x2F;&#x2F; plusequals test for += 100 -= 100
	rplusequals = &#x2F;^([\-+])=\s*(\d+\.?\d*)&#x2F;,
	&#x2F;&#x2F; a set of RE&#x27;s that can match strings and generate color tuples.
	stringParsers = [{
			re: &#x2F;rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)&#x2F;,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: &#x2F;rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)&#x2F;,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			&#x2F;&#x2F; this regex ignores A-F because it&#x27;s compared against an already lowercased string
			re: &#x2F;#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})&#x2F;,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			&#x2F;&#x2F; this regex ignores A-F because it&#x27;s compared against an already lowercased string
			re: &#x2F;#([a-f0-9])([a-f0-9])([a-f0-9])&#x2F;,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: &#x2F;hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)&#x2F;,
			space: &quot;hsla&quot;,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] &#x2F; 100,
					execResult[ 3 ] &#x2F; 100,
					execResult[ 4 ]
				];
			}
		}],

	&#x2F;&#x2F; jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: &quot;byte&quot;
				},
				green: {
					idx: 1,
					type: &quot;byte&quot;
				},
				blue: {
					idx: 2,
					type: &quot;byte&quot;
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: &quot;degrees&quot;
				},
				saturation: {
					idx: 1,
					type: &quot;percent&quot;
				},
				lightness: {
					idx: 2,
					type: &quot;percent&quot;
				}
			}
		}
	},
	propTypes = {
		&quot;byte&quot;: {
			floor: true,
			max: 255
		},
		&quot;percent&quot;: {
			max: 1
		},
		&quot;degrees&quot;: {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	&#x2F;&#x2F; element for support tests
	supportElem = jQuery( &quot;&lt;p&gt;&quot; )[ 0 ],

	&#x2F;&#x2F; colors = jQuery.Color.names
	colors,

	&#x2F;&#x2F; local aliases of functions called often
	each = jQuery.each;

&#x2F;&#x2F; determine rgba support immediately
supportElem.style.cssText = &quot;background-color:rgba(1,1,1,.5)&quot;;
support.rgba = supportElem.style.backgroundColor.indexOf( &quot;rgba&quot; ) &gt; -1;

&#x2F;&#x2F; define cache name and alpha properties
&#x2F;&#x2F; for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = &quot;_&quot; + spaceName;
	space.props.alpha = {
		idx: 3,
		type: &quot;percent&quot;,
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	&#x2F;&#x2F; ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	&#x2F;&#x2F; IE will pass in empty strings as value for alpha,
	&#x2F;&#x2F; which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		&#x2F;&#x2F; we add mod before modding to make sure that negatives values
		&#x2F;&#x2F; get converted properly: -10 -&gt; 350
		return (value + type.mod) % type.mod;
	}

	&#x2F;&#x2F; for now all property types without mod have min and max
	return 0 &gt; value ? 0 : type.max &lt; value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match &amp;&amp; parser.parse( match ),
			spaceName = parser.space || &quot;rgba&quot;;

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			&#x2F;&#x2F; if this was an rgba parse the assignment might happen twice
			&#x2F;&#x2F; oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			&#x2F;&#x2F; exit each( stringParsers ) here because we matched
			return false;
		}
	});

	&#x2F;&#x2F; Found a stringParser that handled it
	if ( rgba.length ) {

		&#x2F;&#x2F; if this came from a parsed string, force &quot;transparent&quot; when alpha is 0
		&#x2F;&#x2F; chrome, (and maybe others) return &quot;transparent&quot; as rgba(0,0,0,0)
		if ( rgba.join() === &quot;0,0,0,0&quot; ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	&#x2F;&#x2F; named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		&#x2F;&#x2F; more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = &quot;array&quot;;
		}

		if ( type === &quot;string&quot; ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === &quot;array&quot; ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === &quot;object&quot; ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						&#x2F;&#x2F; if the cache doesn&#x27;t exist, and we know how to convert
						if ( !inst[ cache ] &amp;&amp; space.to ) {

							&#x2F;&#x2F; if the value was null, we don&#x27;t need to copy it
							&#x2F;&#x2F; if the key was alpha, we don&#x27;t need to copy it either
							if ( key === &quot;alpha&quot; || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						&#x2F;&#x2F; this is the only case where we allow nulls for ALL properties.
						&#x2F;&#x2F; call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					&#x2F;&#x2F; everything defined but alpha?
					if ( inst[ cache ] &amp;&amp; $.inArray( null, inst[ cache ].slice( 0, 3 ) ) &lt; 0 ) {
						&#x2F;&#x2F; use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to &amp;&amp; space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( &quot;transparent&quot; ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			&#x2F;&#x2F; if null, don&#x27;t override start value
			if ( endValue === null ) {
				return;
			}
			&#x2F;&#x2F; if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue &gt; type.mod &#x2F; 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue &gt; type.mod &#x2F; 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		&#x2F;&#x2F; if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = &quot;rgba(&quot;,
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i &gt; 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = &quot;rgb(&quot;;
		}

		return prefix + rgba.join() + &quot;)&quot;;
	},
	toHslaString: function() {
		var prefix = &quot;hsla(&quot;,
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i &gt; 2 ? 1 : 0;
				}

				&#x2F;&#x2F; catch 1 and 2
				if ( i &amp;&amp; i &lt; 3 ) {
					v = Math.round( v * 100 ) + &quot;%&quot;;
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = &quot;hsl(&quot;;
		}
		return prefix + hsla.join() + &quot;)&quot;;
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return &quot;#&quot; + jQuery.map( rgba, function( v ) {

			&#x2F;&#x2F; default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? &quot;0&quot; + v : v;
		}).join(&quot;&quot;);
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? &quot;transparent&quot; : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

&#x2F;&#x2F; hsla conversions adapted from:
&#x2F;&#x2F; https:&#x2F;&#x2F;code.google.com&#x2F;p&#x2F;maashaack&#x2F;source&#x2F;browse&#x2F;packages&#x2F;graphics&#x2F;trunk&#x2F;src&#x2F;graphics&#x2F;colors&#x2F;HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 &lt; 1 ) {
		return p + (q - p) * h * 6;
	}
	if ( h * 2 &lt; 1) {
		return q;
	}
	if ( h * 3 &lt; 2 ) {
		return p + (q - p) * ((2&#x2F;3) - h) * 6;
	}
	return p;
}

spaces.hsla.to = function ( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] &#x2F; 255,
		g = rgba[ 1 ] &#x2F; 255,
		b = rgba[ 2 ] &#x2F; 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) &#x2F; diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) &#x2F; diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) &#x2F; diff ) + 240;
	}

	if ( l === 0 || l === 1 ) {
		s = l;
	} else if ( l &lt;= 0.5 ) {
		s = diff &#x2F; add;
	} else {
		s = diff &#x2F; ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function ( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] &#x2F; 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l &lt;= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 &#x2F; 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 &#x2F; 3 ) ) * 255 ),
		a
	];
};


each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	&#x2F;&#x2F; makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		&#x2F;&#x2F; generate a cache for this space if it doesn&#x27;t exist
		if ( to &amp;&amp; !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === &quot;array&quot; || type === &quot;object&quot; ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === &quot;object&quot; ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	&#x2F;&#x2F; makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		&#x2F;&#x2F; alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === &quot;alpha&quot; ? ( this._hsla ? &quot;hsla&quot; : &quot;rgba&quot; ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === &quot;undefined&quot; ) {
				return cur;
			}

			if ( vtype === &quot;function&quot; ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null &amp;&amp; prop.empty ) {
				return this;
			}
			if ( vtype === &quot;string&quot; ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === &quot;+&quot; ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

&#x2F;&#x2F; add .fx.step functions
each( stepHooks, function( i, hook ) {
	jQuery.cssHooks[ hook ] = {
		set: function( elem, value ) {
			var parsed, curElem,
				backgroundColor = &quot;&quot;;

			if ( jQuery.type( value ) !== &quot;string&quot; || ( parsed = stringParse( value ) ) ) {
				value = color( parsed || value );
				if ( !support.rgba &amp;&amp; value._rgba[ 3 ] !== 1 ) {
					curElem = hook === &quot;backgroundColor&quot; ? elem.parentNode : elem;
					while (
						(backgroundColor === &quot;&quot; || backgroundColor === &quot;transparent&quot;) &amp;&amp;
						curElem &amp;&amp; curElem.style
					) {
						try {
							backgroundColor = jQuery.css( curElem, &quot;backgroundColor&quot; );
							curElem = curElem.parentNode;
						} catch ( e ) {
						}
					}

					value = value.blend( backgroundColor &amp;&amp; backgroundColor !== &quot;transparent&quot; ?
						backgroundColor :
						&quot;_default&quot; );
				}

				value = value.toRgbaString();
			}
			try {
				elem.style[ hook ] = value;
			} catch( error ) {
				&#x2F;&#x2F; wrapped to prevent IE from throwing errors on &quot;invalid&quot; values like &#x27;auto&#x27; or &#x27;inherit&#x27;
			}
		}
	};
	jQuery.fx.step[ hook ] = function( fx ) {
		if ( !fx.colorInit ) {
			fx.start = color( fx.elem, hook );
			fx.end = color( fx.end );
			fx.colorInit = true;
		}
		jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
	};
});

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ &quot;Top&quot;, &quot;Right&quot;, &quot;Bottom&quot;, &quot;Left&quot; ], function( i, part ) {
			expanded[ &quot;border&quot; + part + &quot;Color&quot; ] = value;
		});
		return expanded;
	}
};

&#x2F;&#x2F; Basic color names only.
&#x2F;&#x2F; Usage of any of the other color names requires adding yourself or including
&#x2F;&#x2F; jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	&#x2F;&#x2F; 4.1. Basic color keywords
	aqua: &quot;#00ffff&quot;,
	black: &quot;#000000&quot;,
	blue: &quot;#0000ff&quot;,
	fuchsia: &quot;#ff00ff&quot;,
	gray: &quot;#808080&quot;,
	green: &quot;#008000&quot;,
	lime: &quot;#00ff00&quot;,
	maroon: &quot;#800000&quot;,
	navy: &quot;#000080&quot;,
	olive: &quot;#808000&quot;,
	purple: &quot;#800080&quot;,
	red: &quot;#ff0000&quot;,
	silver: &quot;#c0c0c0&quot;,
	teal: &quot;#008080&quot;,
	white: &quot;#ffffff&quot;,
	yellow: &quot;#ffff00&quot;,

	&#x2F;&#x2F; 4.2.3. &quot;transparent&quot; color keyword
	transparent: [ null, null, null, 0 ],

	_default: &quot;#ffffff&quot;
};

})( jQuery );



&#x2F;******************************************************************************&#x2F;
&#x2F;****************************** CLASS ANIMATIONS ******************************&#x2F;
&#x2F;******************************************************************************&#x2F;
(function() {

var classAnimationActions = [ &quot;add&quot;, &quot;remove&quot;, &quot;toggle&quot; ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ &quot;borderLeftStyle&quot;, &quot;borderRightStyle&quot;, &quot;borderBottomStyle&quot;, &quot;borderTopStyle&quot; ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== &quot;none&quot; &amp;&amp; !fx.setAttr || fx.pos === 1 &amp;&amp; !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles() {
	var style = this.ownerDocument.defaultView ?
			this.ownerDocument.defaultView.getComputedStyle( this, null ) :
			this.currentStyle,
		newStyle = {},
		key,
		len;

	&#x2F;&#x2F; webkit enumerates style porperties
	if ( style &amp;&amp; style.length &amp;&amp; style[ 0 ] &amp;&amp; style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === &quot;string&quot; ) {
				newStyle[ $.camelCase( key ) ] = style[ key ];
			}
		}
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === &quot;string&quot; ) {
				newStyle[ key ] = style[ key ];
			}
		}
	}

	return newStyle;
}


function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( &quot;class&quot; ) || &quot;&quot;,
			applyClassChange,
			allAnimations = o.children ? animated.find( &quot;*&quot; ).andSelf() : animated;

		&#x2F;&#x2F; map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles.call( this )
			};
		});

		&#x2F;&#x2F; apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + &quot;Class&quot; ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		&#x2F;&#x2F; map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles.call( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		&#x2F;&#x2F; apply original class
		animated.attr( &quot;class&quot;, baseClass );

		&#x2F;&#x2F; map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = jQuery.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		&#x2F;&#x2F; once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			&#x2F;&#x2F; set the final class
			applyClassChange();

			&#x2F;&#x2F; for each animated element,
			&#x2F;&#x2F; clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, &#x27;&#x27; );
				});
			});

			&#x2F;&#x2F; this is guarnteed to be there if you use jQuery.speed()
			&#x2F;&#x2F; it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	addClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ add: classNames }, speed, easing, callback ) :
			this._addClass( classNames );
	},

	_removeClass: $.fn.removeClass,
	removeClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ remove: classNames }, speed, easing, callback ) :
			this._removeClass( classNames );
	},

	_toggleClass: $.fn.toggleClass,
	toggleClass: function( classNames, force, speed, easing, callback ) {
		if ( typeof force === &quot;boolean&quot; || force === undefined ) {
			if ( !speed ) {
				&#x2F;&#x2F; without speed parameter
				return this._toggleClass( classNames, force );
			} else {
				return $.effects.animateClass.call( this,
					(force ? { add: classNames } : { remove: classNames }),
					speed, easing, callback );
			}
		} else {
			&#x2F;&#x2F; without force parameter
			return $.effects.animateClass.call( this,
				{ toggle: classNames }, force, speed, easing );
		}
	},

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

&#x2F;******************************************************************************&#x2F;
&#x2F;*********************************** EFFECTS **********************************&#x2F;
&#x2F;******************************************************************************&#x2F;

(function() {

$.extend( $.effects, {
	version: &quot;1.9.2&quot;,

	&#x2F;&#x2F; Saves a set of properties in a data storage
	save: function( element, set ) {
		for( var i=0; i &lt; set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	&#x2F;&#x2F; Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for( i=0; i &lt; set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				&#x2F;&#x2F; support: jQuery 1.6.2
				&#x2F;&#x2F; http:&#x2F;&#x2F;bugs.jquery.com&#x2F;ticket&#x2F;9917
				&#x2F;&#x2F; jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				&#x2F;&#x2F; We can&#x27;t differentiate between &quot;&quot; and 0 here, so we just assume
				&#x2F;&#x2F; empty string since it&#x27;s likely to be a more common value...
				if ( val === undefined ) {
					val = &quot;&quot;;
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === &quot;toggle&quot;) {
			mode = el.is( &quot;:hidden&quot; ) ? &quot;show&quot; : &quot;hide&quot;;
		}
		return mode;
	},

	&#x2F;&#x2F; Translates a [top,left] array into a baseline value
	&#x2F;&#x2F; this should be a little more flexible in the future to handle a string &amp; hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case &quot;top&quot;: y = 0; break;
			case &quot;middle&quot;: y = 0.5; break;
			case &quot;bottom&quot;: y = 1; break;
			default: y = origin[ 0 ] &#x2F; original.height;
		}
		switch ( origin[ 1 ] ) {
			case &quot;left&quot;: x = 0; break;
			case &quot;center&quot;: x = 0.5; break;
			case &quot;right&quot;: x = 1; break;
			default: x = origin[ 1 ] &#x2F; original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	&#x2F;&#x2F; Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		&#x2F;&#x2F; if the element is already wrapped, return it
		if ( element.parent().is( &quot;.ui-effects-wrapper&quot; )) {
			return element.parent();
		}

		&#x2F;&#x2F; wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				&quot;float&quot;: element.css( &quot;float&quot; )
			},
			wrapper = $( &quot;&lt;div&gt;&lt;&#x2F;div&gt;&quot; )
				.addClass( &quot;ui-effects-wrapper&quot; )
				.css({
					fontSize: &quot;100%&quot;,
					background: &quot;transparent&quot;,
					border: &quot;none&quot;,
					margin: 0,
					padding: 0
				}),
			&#x2F;&#x2F; Store the size in case width&#x2F;height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		&#x2F;&#x2F; support: Firefox
		&#x2F;&#x2F; Firefox incorrectly exposes anonymous content
		&#x2F;&#x2F; https:&#x2F;&#x2F;bugzilla.mozilla.org&#x2F;show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		&#x2F;&#x2F; Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); &#x2F;&#x2F;Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		&#x2F;&#x2F; transfer positioning properties to the wrapper
		if ( element.css( &quot;position&quot; ) === &quot;static&quot; ) {
			wrapper.css({ position: &quot;relative&quot; });
			element.css({ position: &quot;relative&quot; });
		} else {
			$.extend( props, {
				position: element.css( &quot;position&quot; ),
				zIndex: element.css( &quot;z-index&quot; )
			});
			$.each([ &quot;top&quot;, &quot;left&quot;, &quot;bottom&quot;, &quot;right&quot; ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = &quot;auto&quot;;
				}
			});
			element.css({
				position: &quot;relative&quot;,
				top: 0,
				left: 0,
				right: &quot;auto&quot;,
				bottom: &quot;auto&quot;
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( &quot;.ui-effects-wrapper&quot; ) ) {
			element.parent().replaceWith( element );

			&#x2F;&#x2F; Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}


		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] &gt; 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

&#x2F;&#x2F; return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	&#x2F;&#x2F; allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	&#x2F;&#x2F; convert to an object
	effect = { effect: effect };

	&#x2F;&#x2F; catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	&#x2F;&#x2F; catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	&#x2F;&#x2F; catch (effect, speed, ?)
	if ( typeof options === &quot;number&quot; || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	&#x2F;&#x2F; catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	&#x2F;&#x2F; add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === &quot;number&quot; ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardSpeed( speed ) {
	&#x2F;&#x2F; valid standard speeds
	if ( !speed || typeof speed === &quot;number&quot; || $.fx.speeds[ speed ] ) {
		return true;
	}

	&#x2F;&#x2F; invalid strings - treat as &quot;normal&quot; speed
	if ( typeof speed === &quot;string&quot; &amp;&amp; !$.effects.effect[ speed ] ) {
		&#x2F;&#x2F; TODO: remove in 2.0 (#7115)
		if ( backCompat &amp;&amp; $.effects[ speed ] ) {
			return false;
		}
		return true;
	}

	return false;
}

$.fn.extend({
	effect: function( &#x2F;* effect, options, speed, callback *&#x2F; ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ],

			&#x2F;&#x2F; DEPRECATED: remove in 2.0 (#7115)
			oldEffectMethod = !effectMethod &amp;&amp; backCompat &amp;&amp; $.effects[ args.effect ];

		if ( $.fx.off || !( effectMethod || oldEffectMethod ) ) {
			&#x2F;&#x2F; delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			&#x2F;&#x2F; if the element is hiddden and mode is hide,
			&#x2F;&#x2F; or element is visible and mode is show
			if ( elem.is( &quot;:hidden&quot; ) ? mode === &quot;hide&quot; : mode === &quot;show&quot; ) {
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		&#x2F;&#x2F; TODO: remove this check in 2.0, effectMethod will always be true
		if ( effectMethod ) {
			return queue === false ? this.each( run ) : this.queue( queue || &quot;fx&quot;, run );
		} else {
			&#x2F;&#x2F; DEPRECATED: remove in 2.0 (#7115)
			return oldEffectMethod.call(this, {
				options: args,
				duration: args.duration,
				callback: args.complete,
				mode: args.mode
			});
		}
	},

	_show: $.fn.show,
	show: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._show.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = &quot;show&quot;;
			return this.effect.call( this, args );
		}
	},

	_hide: $.fn.hide,
	hide: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._hide.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = &quot;hide&quot;;
			return this.effect.call( this, args );
		}
	},

	&#x2F;&#x2F; jQuery core overloads toggle and creates _toggle
	__toggle: $.fn.toggle,
	toggle: function( speed ) {
		if ( standardSpeed( speed ) || typeof speed === &quot;boolean&quot; || $.isFunction( speed ) ) {
			return this.__toggle.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = &quot;toggle&quot;;
			return this.effect.call( this, args );
		}
	},

	&#x2F;&#x2F; helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ &quot;em&quot;, &quot;px&quot;, &quot;%&quot;, &quot;pt&quot; ], function( i, unit ) {
			if ( style.indexOf( unit ) &gt; 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

&#x2F;******************************************************************************&#x2F;
&#x2F;*********************************** EASING ***********************************&#x2F;
&#x2F;******************************************************************************&#x2F;

(function() {

&#x2F;&#x2F; based on easing equations from Robert Penner (http:&#x2F;&#x2F;www.robertpenner.com&#x2F;easing)

var baseEasings = {};

$.each( [ &quot;Quad&quot;, &quot;Cubic&quot;, &quot;Quart&quot;, &quot;Quint&quot;, &quot;Expo&quot; ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI &#x2F; 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI &#x2F; 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p &lt; ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) &#x2F; 11 ) {}
		return 1 &#x2F; Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) &#x2F; 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ &quot;easeIn&quot; + name ] = easeIn;
	$.easing[ &quot;easeOut&quot; + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ &quot;easeInOut&quot; + name ] = function( p ) {
		return p &lt; 0.5 ?
			easeIn( p * 2 ) &#x2F; 2 :
			1 - easeIn( p * -2 + 2 ) &#x2F; 2;
	};
});

})();

})(jQuery));
(function( $, undefined ) {

var rvertical = &#x2F;up|down|vertical&#x2F;,
	rpositivemotion = &#x2F;up|left|vertical|horizontal&#x2F;;

$.effects.effect.blind = function( o, done ) {
	&#x2F;&#x2F; Create element
	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;height&quot;, &quot;width&quot; ],
		mode = $.effects.setMode( el, o.mode || &quot;hide&quot; ),
		direction = o.direction || &quot;up&quot;,
		vertical = rvertical.test( direction ),
		ref = vertical ? &quot;height&quot; : &quot;width&quot;,
		ref2 = vertical ? &quot;top&quot; : &quot;left&quot;,
		motion = rpositivemotion.test( direction ),
		animation = {},
		show = mode === &quot;show&quot;,
		wrapper, distance, margin;

	&#x2F;&#x2F; if already wrapped, the wrapper&#x27;s properties are my property. #6245
	if ( el.parent().is( &quot;.ui-effects-wrapper&quot; ) ) {
		$.effects.save( el.parent(), props );
	} else {
		$.effects.save( el, props );
	}
	el.show();
	wrapper = $.effects.createWrapper( el ).css({
		overflow: &quot;hidden&quot;
	});

	distance = wrapper[ ref ]();
	margin = parseFloat( wrapper.css( ref2 ) ) || 0;

	animation[ ref ] = show ? distance : 0;
	if ( !motion ) {
		el
			.css( vertical ? &quot;bottom&quot; : &quot;right&quot;, 0 )
			.css( vertical ? &quot;top&quot; : &quot;left&quot;, &quot;auto&quot; )
			.css({ position: &quot;absolute&quot; });

		animation[ ref2 ] = show ? margin : distance + margin;
	}

	&#x2F;&#x2F; start at 0 if we are showing
	if ( show ) {
		wrapper.css( ref, 0 );
		if ( ! motion ) {
			wrapper.css( ref2, margin + distance );
		}
	}

	&#x2F;&#x2F; Animate
	wrapper.animate( animation, {
		duration: o.duration,
		easing: o.easing,
		queue: false,
		complete: function() {
			if ( mode === &quot;hide&quot; ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.bounce = function( o, done ) {
	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;height&quot;, &quot;width&quot; ],

		&#x2F;&#x2F; defaults:
		mode = $.effects.setMode( el, o.mode || &quot;effect&quot; ),
		hide = mode === &quot;hide&quot;,
		show = mode === &quot;show&quot;,
		direction = o.direction || &quot;up&quot;,
		distance = o.distance,
		times = o.times || 5,

		&#x2F;&#x2F; number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = o.duration &#x2F; anims,
		easing = o.easing,

		&#x2F;&#x2F; utility:
		ref = ( direction === &quot;up&quot; || direction === &quot;down&quot; ) ? &quot;top&quot; : &quot;left&quot;,
		motion = ( direction === &quot;up&quot; || direction === &quot;left&quot; ),
		i,
		upAnim,
		downAnim,

		&#x2F;&#x2F; we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	&#x2F;&#x2F; Avoid touching opacity to prevent clearType and PNG issues in IE
	if ( show || hide ) {
		props.push( &quot;opacity&quot; );
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el ); &#x2F;&#x2F; Create Wrapper

	&#x2F;&#x2F; default distance for the BIGGEST bounce is the outer Distance &#x2F; 3
	if ( !distance ) {
		distance = el[ ref === &quot;top&quot; ? &quot;outerHeight&quot; : &quot;outerWidth&quot; ]() &#x2F; 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = 0;

		&#x2F;&#x2F; if we are showing, force opacity 0 and set the initial position
		&#x2F;&#x2F; then do the &quot;first&quot; animation
		el.css( &quot;opacity&quot;, 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	&#x2F;&#x2F; start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance &#x2F; Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = 0;
	&#x2F;&#x2F; Bounces up&#x2F;down&#x2F;left&#x2F;right then back to 0 -- times * 2 animations happen here
	for ( i = 0; i &lt; times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? &quot;-=&quot; : &quot;+=&quot; ) + distance;

		el.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance &#x2F; 2;
	}

	&#x2F;&#x2F; Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? &quot;-=&quot; : &quot;+=&quot; ) + distance;

		el.animate( upAnim, speed, easing );
	}

	el.queue(function() {
		if ( hide ) {
			el.hide();
		}
		$.effects.restore( el, props );
		$.effects.removeWrapper( el );
		done();
	});

	&#x2F;&#x2F; inject all the animations we just queued to be first in line (after &quot;inprogress&quot;)
	if ( queuelen &gt; 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.clip = function( o, done ) {
	&#x2F;&#x2F; Create element
	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;height&quot;, &quot;width&quot; ],
		mode = $.effects.setMode( el, o.mode || &quot;hide&quot; ),
		show = mode === &quot;show&quot;,
		direction = o.direction || &quot;vertical&quot;,
		vert = direction === &quot;vertical&quot;,
		size = vert ? &quot;height&quot; : &quot;width&quot;,
		position = vert ? &quot;top&quot; : &quot;left&quot;,
		animation = {},
		wrapper, animate, distance;

	&#x2F;&#x2F; Save &amp; Show
	$.effects.save( el, props );
	el.show();

	&#x2F;&#x2F; Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: &quot;hidden&quot;
	});
	animate = ( el[0].tagName === &quot;IMG&quot; ) ? wrapper : el;
	distance = animate[ size ]();

	&#x2F;&#x2F; Shift
	if ( show ) {
		animate.css( size, 0 );
		animate.css( position, distance &#x2F; 2 );
	}

	&#x2F;&#x2F; Create Animation Object:
	animation[ size ] = show ? distance : 0;
	animation[ position ] = show ? 0 : distance &#x2F; 2;

	&#x2F;&#x2F; Animate
	animate.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( !show ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.drop = function( o, done ) {

	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;opacity&quot;, &quot;height&quot;, &quot;width&quot; ],
		mode = $.effects.setMode( el, o.mode || &quot;hide&quot; ),
		show = mode === &quot;show&quot;,
		direction = o.direction || &quot;left&quot;,
		ref = ( direction === &quot;up&quot; || direction === &quot;down&quot; ) ? &quot;top&quot; : &quot;left&quot;,
		motion = ( direction === &quot;up&quot; || direction === &quot;left&quot; ) ? &quot;pos&quot; : &quot;neg&quot;,
		animation = {
			opacity: show ? 1 : 0
		},
		distance;

	&#x2F;&#x2F; Adjust
	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	distance = o.distance || el[ ref === &quot;top&quot; ? &quot;outerHeight&quot;: &quot;outerWidth&quot; ]( true ) &#x2F; 2;

	if ( show ) {
		el
			.css( &quot;opacity&quot;, 0 )
			.css( ref, motion === &quot;pos&quot; ? -distance : distance );
	}

	&#x2F;&#x2F; Animation
	animation[ ref ] = ( show ?
		( motion === &quot;pos&quot; ? &quot;+=&quot; : &quot;-=&quot; ) :
		( motion === &quot;pos&quot; ? &quot;-=&quot; : &quot;+=&quot; ) ) +
		distance;

	&#x2F;&#x2F; Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === &quot;hide&quot; ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.explode = function( o, done ) {

	var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
		cells = rows,
		el = $( this ),
		mode = $.effects.setMode( el, o.mode || &quot;hide&quot; ),
		show = mode === &quot;show&quot;,

		&#x2F;&#x2F; show and then visibility:hidden the element before calculating offset
		offset = el.show().css( &quot;visibility&quot;, &quot;hidden&quot; ).offset(),

		&#x2F;&#x2F; width and height of a piece
		width = Math.ceil( el.outerWidth() &#x2F; cells ),
		height = Math.ceil( el.outerHeight() &#x2F; rows ),
		pieces = [],

		&#x2F;&#x2F; loop
		i, j, left, top, mx, my;

	&#x2F;&#x2F; children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	&#x2F;&#x2F; clone the element for each row and cell.
	for( i = 0; i &lt; rows ; i++ ) { &#x2F;&#x2F; ===&gt;
		top = offset.top + i * height;
		my = i - ( rows - 1 ) &#x2F; 2 ;

		for( j = 0; j &lt; cells ; j++ ) { &#x2F;&#x2F; |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) &#x2F; 2 ;

			&#x2F;&#x2F; Create a clone of the now hidden main element that will be absolute positioned
			&#x2F;&#x2F; within a wrapper div off the -left and -top equal to size of our pieces
			el
				.clone()
				.appendTo( &quot;body&quot; )
				.wrap( &quot;&lt;div&gt;&lt;&#x2F;div&gt;&quot; )
				.css({
					position: &quot;absolute&quot;,
					visibility: &quot;visible&quot;,
					left: -j * width,
					top: -i * height
				})

			&#x2F;&#x2F; select the wrapper - make it overflow: hidden and absolute positioned based on
			&#x2F;&#x2F; where the original was located +left and +top equal to the size of pieces
				.parent()
				.addClass( &quot;ui-effects-explode&quot; )
				.css({
					position: &quot;absolute&quot;,
					overflow: &quot;hidden&quot;,
					width: width,
					height: height,
					left: left + ( show ? mx * width : 0 ),
					top: top + ( show ? my * height : 0 ),
					opacity: show ? 0 : 1
				}).animate({
					left: left + ( show ? 0 : mx * width ),
					top: top + ( show ? 0 : my * height ),
					opacity: show ? 1 : 0
				}, o.duration || 500, o.easing, childComplete );
		}
	}

	function animComplete() {
		el.css({
			visibility: &quot;visible&quot;
		});
		$( pieces ).remove();
		if ( !show ) {
			el.hide();
		}
		done();
	}
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.fade = function( o, done ) {
	var el = $( this ),
		mode = $.effects.setMode( el, o.mode || &quot;toggle&quot; );

	el.animate({
		opacity: mode
	}, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: done
	});
};

})( jQuery );
(function( $, undefined ) {

$.effects.effect.fold = function( o, done ) {

	&#x2F;&#x2F; Create element
	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;height&quot;, &quot;width&quot; ],
		mode = $.effects.setMode( el, o.mode || &quot;hide&quot; ),
		show = mode === &quot;show&quot;,
		hide = mode === &quot;hide&quot;,
		size = o.size || 15,
		percent = &#x2F;([0-9]+)%&#x2F;.exec( size ),
		horizFirst = !!o.horizFirst,
		widthFirst = show !== horizFirst,
		ref = widthFirst ? [ &quot;width&quot;, &quot;height&quot; ] : [ &quot;height&quot;, &quot;width&quot; ],
		duration = o.duration &#x2F; 2,
		wrapper, distance,
		animation1 = {},
		animation2 = {};

	$.effects.save( el, props );
	el.show();

	&#x2F;&#x2F; Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: &quot;hidden&quot;
	});
	distance = widthFirst ?
		[ wrapper.width(), wrapper.height() ] :
		[ wrapper.height(), wrapper.width() ];

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) &#x2F; 100 * distance[ hide ? 0 : 1 ];
	}
	if ( show ) {
		wrapper.css( horizFirst ? {
			height: 0,
			width: size
		} : {
			height: size,
			width: 0
		});
	}

	&#x2F;&#x2F; Animation
	animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
	animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

	&#x2F;&#x2F; Animate
	wrapper
		.animate( animation1, duration, o.easing )
		.animate( animation2, duration, o.easing, function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.highlight = function( o, done ) {
	var elem = $( this ),
		props = [ &quot;backgroundImage&quot;, &quot;backgroundColor&quot;, &quot;opacity&quot; ],
		mode = $.effects.setMode( elem, o.mode || &quot;show&quot; ),
		animation = {
			backgroundColor: elem.css( &quot;backgroundColor&quot; )
		};

	if (mode === &quot;hide&quot;) {
		animation.opacity = 0;
	}

	$.effects.save( elem, props );

	elem
		.show()
		.css({
			backgroundImage: &quot;none&quot;,
			backgroundColor: o.color || &quot;#ffff99&quot;
		})
		.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === &quot;hide&quot; ) {
					elem.hide();
				}
				$.effects.restore( elem, props );
				done();
			}
		});
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.pulsate = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || &quot;show&quot; ),
		show = mode === &quot;show&quot;,
		hide = mode === &quot;hide&quot;,
		showhide = ( show || mode === &quot;hide&quot; ),

		&#x2F;&#x2F; showing or hiding leaves of the &quot;last&quot; animation
		anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = o.duration &#x2F; anims,
		animateTo = 0,
		queue = elem.queue(),
		queuelen = queue.length,
		i;

	if ( show || !elem.is(&quot;:visible&quot;)) {
		elem.css( &quot;opacity&quot;, 0 ).show();
		animateTo = 1;
	}

	&#x2F;&#x2F; anims - 1 opacity &quot;toggles&quot;
	for ( i = 1; i &lt; anims; i++ ) {
		elem.animate({
			opacity: animateTo
		}, duration, o.easing );
		animateTo = 1 - animateTo;
	}

	elem.animate({
		opacity: animateTo
	}, duration, o.easing);

	elem.queue(function() {
		if ( hide ) {
			elem.hide();
		}
		done();
	});

	&#x2F;&#x2F; We just queued up &quot;anims&quot; animations, we need to put them next in the queue
	if ( queuelen &gt; 1 ) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	elem.dequeue();
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.puff = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || &quot;hide&quot; ),
		hide = mode === &quot;hide&quot;,
		percent = parseInt( o.percent, 10 ) || 150,
		factor = percent &#x2F; 100,
		original = {
			height: elem.height(),
			width: elem.width(),
			outerHeight: elem.outerHeight(),
			outerWidth: elem.outerWidth()
		};

	$.extend( o, {
		effect: &quot;scale&quot;,
		queue: false,
		fade: true,
		mode: mode,
		complete: done,
		percent: hide ? percent : 100,
		from: hide ?
			original :
			{
				height: original.height * factor,
				width: original.width * factor,
				outerHeight: original.outerHeight * factor,
				outerWidth: original.outerWidth * factor
			}
	});

	elem.effect( o );
};

$.effects.effect.scale = function( o, done ) {

	&#x2F;&#x2F; Create element
	var el = $( this ),
		options = $.extend( true, {}, o ),
		mode = $.effects.setMode( el, o.mode || &quot;effect&quot; ),
		percent = parseInt( o.percent, 10 ) ||
			( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === &quot;hide&quot; ? 0 : 100 ) ),
		direction = o.direction || &quot;both&quot;,
		origin = o.origin,
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		},
		factor = {
			y: direction !== &quot;horizontal&quot; ? (percent &#x2F; 100) : 1,
			x: direction !== &quot;vertical&quot; ? (percent &#x2F; 100) : 1
		};

	&#x2F;&#x2F; We are going to pass this effect to the size effect:
	options.effect = &quot;size&quot;;
	options.queue = false;
	options.complete = done;

	&#x2F;&#x2F; Set default origin and restore for show&#x2F;hide
	if ( mode !== &quot;effect&quot; ) {
		options.origin = origin || [&quot;middle&quot;,&quot;center&quot;];
		options.restore = true;
	}

	options.from = o.from || ( mode === &quot;show&quot; ? {
		height: 0,
		width: 0,
		outerHeight: 0,
		outerWidth: 0
	} : original );
	options.to = {
		height: original.height * factor.y,
		width: original.width * factor.x,
		outerHeight: original.outerHeight * factor.y,
		outerWidth: original.outerWidth * factor.x
	};

	&#x2F;&#x2F; Fade option to support puff
	if ( options.fade ) {
		if ( mode === &quot;show&quot; ) {
			options.from.opacity = 0;
			options.to.opacity = 1;
		}
		if ( mode === &quot;hide&quot; ) {
			options.from.opacity = 1;
			options.to.opacity = 0;
		}
	}

	&#x2F;&#x2F; Animate
	el.effect( options );

};

$.effects.effect.size = function( o, done ) {

	&#x2F;&#x2F; Create element
	var original, baseline, factor,
		el = $( this ),
		props0 = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;width&quot;, &quot;height&quot;, &quot;overflow&quot;, &quot;opacity&quot; ],

		&#x2F;&#x2F; Always restore
		props1 = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;overflow&quot;, &quot;opacity&quot; ],

		&#x2F;&#x2F; Copy for children
		props2 = [ &quot;width&quot;, &quot;height&quot;, &quot;overflow&quot; ],
		cProps = [ &quot;fontSize&quot; ],
		vProps = [ &quot;borderTopWidth&quot;, &quot;borderBottomWidth&quot;, &quot;paddingTop&quot;, &quot;paddingBottom&quot; ],
		hProps = [ &quot;borderLeftWidth&quot;, &quot;borderRightWidth&quot;, &quot;paddingLeft&quot;, &quot;paddingRight&quot; ],

		&#x2F;&#x2F; Set options
		mode = $.effects.setMode( el, o.mode || &quot;effect&quot; ),
		restore = o.restore || mode !== &quot;effect&quot;,
		scale = o.scale || &quot;both&quot;,
		origin = o.origin || [ &quot;middle&quot;, &quot;center&quot; ],
		position = el.css( &quot;position&quot; ),
		props = restore ? props0 : props1,
		zero = {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		};

	if ( mode === &quot;show&quot; ) {
		el.show();
	}
	original = {
		height: el.height(),
		width: el.width(),
		outerHeight: el.outerHeight(),
		outerWidth: el.outerWidth()
	};

	if ( o.mode === &quot;toggle&quot; &amp;&amp; mode === &quot;show&quot; ) {
		el.from = o.to || zero;
		el.to = o.from || original;
	} else {
		el.from = o.from || ( mode === &quot;show&quot; ? zero : original );
		el.to = o.to || ( mode === &quot;hide&quot; ? zero : original );
	}

	&#x2F;&#x2F; Set scaling factor
	factor = {
		from: {
			y: el.from.height &#x2F; original.height,
			x: el.from.width &#x2F; original.width
		},
		to: {
			y: el.to.height &#x2F; original.height,
			x: el.to.width &#x2F; original.width
		}
	};

	&#x2F;&#x2F; Scale the css box
	if ( scale === &quot;box&quot; || scale === &quot;both&quot; ) {

		&#x2F;&#x2F; Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( vProps );
			el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
		}

		&#x2F;&#x2F; Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			props = props.concat( hProps );
			el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
			el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
		}
	}

	&#x2F;&#x2F; Scale the content
	if ( scale === &quot;content&quot; || scale === &quot;both&quot; ) {

		&#x2F;&#x2F; Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( cProps ).concat( props2 );
			el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
		}
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );
	el.css( &quot;overflow&quot;, &quot;hidden&quot; ).css( el.from );

	&#x2F;&#x2F; Adjust
	if (origin) { &#x2F;&#x2F; Calculate baseline shifts
		baseline = $.effects.getBaseline( origin, original );
		el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
		el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
		el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
		el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
	}
	el.css( el.from ); &#x2F;&#x2F; set top &amp; left

	&#x2F;&#x2F; Animate
	if ( scale === &quot;content&quot; || scale === &quot;both&quot; ) { &#x2F;&#x2F; Scale the children

		&#x2F;&#x2F; Add margins&#x2F;font-size
		vProps = vProps.concat([ &quot;marginTop&quot;, &quot;marginBottom&quot; ]).concat(cProps);
		hProps = hProps.concat([ &quot;marginLeft&quot;, &quot;marginRight&quot; ]);
		props2 = props0.concat(vProps).concat(hProps);

		el.find( &quot;*[width]&quot; ).each( function(){
			var child = $( this ),
				c_original = {
					height: child.height(),
					width: child.width(),
					outerHeight: child.outerHeight(),
					outerWidth: child.outerWidth()
				};
			if (restore) {
				$.effects.save(child, props2);
			}

			child.from = {
				height: c_original.height * factor.from.y,
				width: c_original.width * factor.from.x,
				outerHeight: c_original.outerHeight * factor.from.y,
				outerWidth: c_original.outerWidth * factor.from.x
			};
			child.to = {
				height: c_original.height * factor.to.y,
				width: c_original.width * factor.to.x,
				outerHeight: c_original.height * factor.to.y,
				outerWidth: c_original.width * factor.to.x
			};

			&#x2F;&#x2F; Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
				child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
			}

			&#x2F;&#x2F; Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
				child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
			}

			&#x2F;&#x2F; Animate children
			child.css( child.from );
			child.animate( child.to, o.duration, o.easing, function() {

				&#x2F;&#x2F; Restore children
				if ( restore ) {
					$.effects.restore( child, props2 );
				}
			});
		});
	}

	&#x2F;&#x2F; Animate
	el.animate( el.to, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( el.to.opacity === 0 ) {
				el.css( &quot;opacity&quot;, el.from.opacity );
			}
			if( mode === &quot;hide&quot; ) {
				el.hide();
			}
			$.effects.restore( el, props );
			if ( !restore ) {

				&#x2F;&#x2F; we need to calculate our new positioning based on the scaling
				if ( position === &quot;static&quot; ) {
					el.css({
						position: &quot;relative&quot;,
						top: el.to.top,
						left: el.to.left
					});
				} else {
					$.each([ &quot;top&quot;, &quot;left&quot; ], function( idx, pos ) {
						el.css( pos, function( _, str ) {
							var val = parseInt( str, 10 ),
								toRef = idx ? el.to.left : el.to.top;

							&#x2F;&#x2F; if original was &quot;auto&quot;, recalculate the new value from wrapper
							if ( str === &quot;auto&quot; ) {
								return toRef + &quot;px&quot;;
							}

							return val + toRef + &quot;px&quot;;
						});
					});
				}
			}

			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.shake = function( o, done ) {

	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;height&quot;, &quot;width&quot; ],
		mode = $.effects.setMode( el, o.mode || &quot;effect&quot; ),
		direction = o.direction || &quot;left&quot;,
		distance = o.distance || 20,
		times = o.times || 3,
		anims = times * 2 + 1,
		speed = Math.round(o.duration&#x2F;anims),
		ref = (direction === &quot;up&quot; || direction === &quot;down&quot;) ? &quot;top&quot; : &quot;left&quot;,
		positiveMotion = (direction === &quot;up&quot; || direction === &quot;left&quot;),
		animation = {},
		animation1 = {},
		animation2 = {},
		i,

		&#x2F;&#x2F; we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	&#x2F;&#x2F; Animation
	animation[ ref ] = ( positiveMotion ? &quot;-=&quot; : &quot;+=&quot; ) + distance;
	animation1[ ref ] = ( positiveMotion ? &quot;+=&quot; : &quot;-=&quot; ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? &quot;-=&quot; : &quot;+=&quot; ) + distance * 2;

	&#x2F;&#x2F; Animate
	el.animate( animation, speed, o.easing );

	&#x2F;&#x2F; Shakes
	for ( i = 1; i &lt; times; i++ ) {
		el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
	}
	el
		.animate( animation1, speed, o.easing )
		.animate( animation, speed &#x2F; 2, o.easing )
		.queue(function() {
			if ( mode === &quot;hide&quot; ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

	&#x2F;&#x2F; inject all the animations we just queued to be first in line (after &quot;inprogress&quot;)
	if ( queuelen &gt; 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.slide = function( o, done ) {

	&#x2F;&#x2F; Create element
	var el = $( this ),
		props = [ &quot;position&quot;, &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, &quot;right&quot;, &quot;width&quot;, &quot;height&quot; ],
		mode = $.effects.setMode( el, o.mode || &quot;show&quot; ),
		show = mode === &quot;show&quot;,
		direction = o.direction || &quot;left&quot;,
		ref = (direction === &quot;up&quot; || direction === &quot;down&quot;) ? &quot;top&quot; : &quot;left&quot;,
		positiveMotion = (direction === &quot;up&quot; || direction === &quot;left&quot;),
		distance,
		animation = {};

	&#x2F;&#x2F; Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === &quot;top&quot; ? &quot;outerHeight&quot; : &quot;outerWidth&quot; ]( true );

	$.effects.createWrapper( el ).css({
		overflow: &quot;hidden&quot;
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? &quot;-&quot; + distance : -distance) : distance );
	}

	&#x2F;&#x2F; Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? &quot;+=&quot; : &quot;-=&quot;) :
		( positiveMotion ? &quot;-=&quot; : &quot;+=&quot;)) +
		distance;

	&#x2F;&#x2F; Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === &quot;hide&quot; ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);
(function( $, undefined ) {

$.effects.effect.transfer = function( o, done ) {
	var elem = $( this ),
		target = $( o.to ),
		targetFixed = target.css( &quot;position&quot; ) === &quot;fixed&quot;,
		body = $(&quot;body&quot;),
		fixTop = targetFixed ? body.scrollTop() : 0,
		fixLeft = targetFixed ? body.scrollLeft() : 0,
		endPosition = target.offset(),
		animation = {
			top: endPosition.top - fixTop ,
			left: endPosition.left - fixLeft ,
			height: target.innerHeight(),
			width: target.innerWidth()
		},
		startPosition = elem.offset(),
		transfer = $( &#x27;&lt;div class=&quot;ui-effects-transfer&quot;&gt;&lt;&#x2F;div&gt;&#x27; )
			.appendTo( document.body )
			.addClass( o.className )
			.css({
				top: startPosition.top - fixTop ,
				left: startPosition.left - fixLeft ,
				height: elem.innerHeight(),
				width: elem.innerWidth(),
				position: targetFixed ? &quot;fixed&quot; : &quot;absolute&quot;
			})
			.animate( animation, o.duration, o.easing, function() {
				transfer.remove();
				done();
			});
};

})(jQuery);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
